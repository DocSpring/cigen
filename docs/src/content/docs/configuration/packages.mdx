---
title: Package Management
description: Dynamic package manager detection and installation built on top of the caching system
---

import {
  Code,
  Aside,
  Steps,
  CardGrid,
  Card,
} from '@astrojs/starlight/components';

The `packages` feature provides intelligent package manager detection, installation, and optimization that builds on top of cigen's [cache system](/configuration/cache). It automatically detects which package manager your project uses and generates the correct installation commands.

## Architecture Overview

<Aside type="note">
  **Packages builds on Cache**: The package system leverages the existing cache system for storage and retrieval, while adding package manager detection and installation logic on top.
</Aside>

The package management system provides:

1. **Dynamic package manager detection** - Detects npm vs yarn vs pnpm based on lock files
2. **Configurable installation commands** - YAML-based definitions for any package manager
3. **Smart job deduplication** - Optimizes workflows when multiple jobs use the same packages
4. **Extensible definitions** - Built-in support for common languages, fully customizable

## Package Manager Definitions

Package managers are defined in YAML configuration with detection rules and installation commands. Cigen includes built-in definitions that you can extend or override.

### Built-in Package Managers

<Code
  code={`# Built into cigen's default configuration
package_managers:
  node:
    versions: [node]
    detect:
      - npm:
          lockfile: package-lock.json
          command: npm ci
      - yarn:
          lockfile: yarn.lock
          command: yarn install --frozen-lockfile
      - pnpm:
          lockfile: pnpm-lock.yaml
          command: pnpm install --frozen-lockfile
      - bun:
          lockfile: bun.lockb
          command: bun install --frozen-lockfile
    checksum_sources:
      - package.json
      - detect: [package-lock.json, yarn.lock, pnpm-lock.yaml, bun.lockb]
    cache_paths: [node_modules]

  ruby:
    versions: [ruby, bundler]
    detect:
      - bundler:
          lockfile: Gemfile.lock
          command: bundle install
    checksum_sources: [Gemfile, Gemfile.lock]
    cache_paths: [vendor/bundle, .bundle]

  python:
    versions: [python]
    detect:
      - pip:
          lockfile: requirements.txt
          command: pip install -r requirements.txt
      - pipenv:
          lockfile: Pipfile.lock
          command: pipenv install --deploy
      - poetry:
          lockfile: poetry.lock
          command: poetry install
    checksum_sources:
      - detect: [requirements.txt, Pipfile, pyproject.toml]
      - detect_optional: [requirements.lock, Pipfile.lock, poetry.lock]
    cache_paths:
      - detect: [.venv, venv]
      - ~/.cache/pip`}
  lang="yaml"
  title="Built-in package manager definitions"
/>

### How Detection Works

When you use `packages: node`, cigen:

1. **Detects the specific tool** - Checks for `package-lock.json` (npm), `yarn.lock` (yarn), `pnpm-lock.yaml` (pnpm), or `bun.lockb` (bun)
2. **Generates the install command** - Uses the appropriate command (`npm ci`, `yarn install --frozen-lockfile`, etc.)
3. **Creates cache configuration** - Leverages the cache system with proper version detection and checksums

## Basic Usage

### Simple Package Installation

<Code
  code={`jobs:
  test:
    image: cimg/node:18.0
    packages: node  # Auto-detects npm/yarn/pnpm/bun
    steps:
      - run: npm test`}
  lang="yaml"
  title="Simple package usage"
/>

This automatically:
1. **Detects** which package manager based on lock files
2. **Restores** the appropriate cache (e.g., `node_modules`)
3. **Runs** the detected install command (e.g., `yarn install --frozen-lockfile`)
4. **Saves** the cache with proper version and checksum keys

### Multiple Package Types

<Code
  code={`jobs:
  full_stack_test:
    image: cimg/ruby:3.3
    packages: [ruby, node]  # Multiple package managers
    services: [postgres]
    steps:
      - run: bundle exec rspec
      - run: npm test`}
  lang="yaml"
  title="Multiple package types"
/>

## Smart Job Deduplication

<Aside type="note">
  **Automatic Optimization**: Cigen detects when multiple jobs use the same
  packages and automatically creates a shared installation job.
</Aside>

### Single Job (Inline Installation)

When only one job uses a package manager, installation runs inline:

<Code
  code={`jobs:
  test:
    packages: node
    steps:
      - run: npm test

# Generated structure:
jobs:
  test:
    cache: node_modules  # Uses cache system with detected package manager
    steps:
      - run: yarn install --frozen-lockfile  # Detected command
      - run: npm test`}
  lang="yaml"
  title="Single job - inline installation"
/>

### Multiple Jobs (Dedicated Installation Job)

When multiple jobs use the same packages, cigen creates a dedicated job:

<Code
  code={`jobs:
  test:
    packages: node
    steps:
      - run: npm test

  lint:
    packages: node
    steps:
      - run: npm run lint

  build:
    packages: node
    steps:
      - run: npm run build

# Generated structure:
jobs:
  install_node_packages:
    cache: node_modules
    steps:
      - run: yarn install --frozen-lockfile  # Detected based on yarn.lock

  test:
    requires: [install_node_packages]
    restore_cache: node_modules  # Read-only cache access
    steps:
      - run: npm test

  lint:
    requires: [install_node_packages]
    restore_cache: node_modules
    steps:
      - run: npm run lint

  build:
    requires: [install_node_packages]
    restore_cache: node_modules
    steps:
      - run: npm run build`}
  lang="yaml"
  title="Multiple jobs - dedicated installation"
/>

## Benefits of Deduplication

The automatic job deduplication provides:

<CardGrid>
  <Card title="Faster CI" icon="rocket">
    Install dependencies once, use everywhere
  </Card>
  <Card title="Better Parallelization" icon="list-format">
    Installation runs in parallel with other setup tasks
  </Card>
  <Card title="Reduced Redundancy" icon="document">
    No duplicate installation commands across jobs
  </Card>
  <Card title="Cache Efficiency" icon="approve-check">
    Single cache save operation reduces overhead
  </Card>
</CardGrid>

## Package Detection

### Lock File Detection

Cigen automatically detects which package manager to use:

<Steps>
  1. **Checks for lock files** in the repository root
  2. **Identifies package manager** from lock file type:
     - `package-lock.json` → npm
     - `yarn.lock` → yarn
     - `pnpm-lock.yaml` → pnpm
     - `bun.lockb` → bun
     - `Gemfile.lock` → bundler
     - `requirements.lock` or `Pipfile.lock` → pip/pipenv
  3. **Runs appropriate install command**
  4. **Caches correct directories** for that package manager
</Steps>

### Install Commands

Based on detection, cigen runs the appropriate command:

| Package Type | Lock File | Install Command |
|-------------|-----------|-----------------|
| `node` (npm) | package-lock.json | `npm ci` |
| `node` (yarn) | yarn.lock | `yarn install --frozen-lockfile` |
| `node` (pnpm) | pnpm-lock.yaml | `pnpm install --frozen-lockfile` |
| `node` (bun) | bun.lockb | `bun install --frozen-lockfile` |
| `ruby` | Gemfile.lock | `bundle install` |
| `python` | requirements.txt | `pip install -r requirements.txt` |
| `python` | Pipfile.lock | `pipenv install --deploy` |
| `go` | go.mod | `go mod download` |

## Customizing Package Managers

### Overriding Built-in Definitions

You can customize the built-in package manager definitions in your configuration:

<Code
  code={`# .cigen/cigen.yml
package_managers:
  node:
    # Override the npm command
    detect:
      - npm:
          lockfile: package-lock.json
          command: npm ci --production  # Custom flags
      - yarn:
          lockfile: yarn.lock
          command: yarn install --frozen-lockfile --production
    # Keep other settings from built-in definition
    versions: [node]
    checksum_sources:
      - package.json
      - detect: [package-lock.json, yarn.lock, pnpm-lock.yaml, bun.lockb]
    cache_paths: [node_modules]`}
  lang="yaml"
  title="Custom package manager commands"
/>

### Adding New Package Managers

Define completely new package managers:

<Code
  code={`# .cigen/cigen.yml
package_managers:
  deno:
    versions: [deno]
    detect:
      - deno:
          lockfile: deno.lock
          command: deno cache deps.ts
    checksum_sources: [deps.ts, deno.lock]
    cache_paths: [~/.cache/deno]

  swift:
    versions: [swift]
    detect:
      - spm:
          lockfile: Package.resolved
          command: swift package resolve
    checksum_sources: [Package.swift, Package.resolved]
    cache_paths: [.build]`}
  lang="yaml"
  title="Adding new package managers"
/>

### Per-Job Customization

Override package behavior for specific jobs:

<Code
  code={`jobs:
  test:
    packages:
      node:
        command: npm ci --ignore-optional  # Job-specific command
        cache_paths: [node_modules, .npm]   # Additional cache paths
    steps:
      - run: npm test`}
  lang="yaml"
  title="Per-job package customization"
/>

## Packages vs Cache

Understanding when to use each:

| Use `packages` when: | Use `cache` when: |
|---------------------|-------------------|
| Installing dependencies | Caching build artifacts |
| Standard package managers | Custom cache scenarios |
| Want automatic commands | Need fine control |
| Multiple jobs share deps | Single job optimization |

### Example: Packages for Dependencies, Cache for Artifacts

<Code
  code={`jobs:
  build:
    packages: [node]  # Install dependencies
    cache:
      webpack:  # Cache build artifacts
        paths: [dist/, .webpack-cache]
        checksum_sources: [webpack.config.js]
    steps:
      - run: npm run build`}
  lang="yaml"
  title="Combined packages and cache usage"
/>

## Migration Guide

### From Manual Installation

Before (manual):
```yaml
jobs:
  test:
    steps:
      - checkout
      - restore_cache: node_modules
      - run: npm install
      - save_cache: node_modules
      - run: npm test
```

After (with packages):
```yaml
jobs:
  test:
    packages: [node]
    steps:
      - run: npm test
```

### From Cache Field

Before (cache only):
```yaml
jobs:
  test:
    cache: node_modules
    steps:
      - run: npm install  # Still needed
      - run: npm test
```

After (with packages):
```yaml
jobs:
  test:
    packages: [node]  # Includes installation
    steps:
      - run: npm test
```

## Best Practices

<CardGrid>
  <Card title="Use for Dependencies" icon="package">
    Use `packages` for dependency installation, `cache` for build artifacts
  </Card>
  <Card title="Let Detection Work" icon="search">
    Trust automatic lock file detection rather than specifying commands
  </Card>
  <Card title="Share When Possible" icon="git-branch">
    Let deduplication optimize when multiple jobs use the same packages
  </Card>
  <Card title="Version Lock Files" icon="document">
    Always commit lock files to ensure reproducible builds
  </Card>
</CardGrid>

## Troubleshooting

### Package Manager Not Detected

If the wrong package manager is used:

1. **Ensure lock file exists** and is committed
2. **Check working directory** is correct
3. **Explicitly specify** if needed:
   ```yaml
   packages:
     node:
       manager: pnpm  # Force specific manager
   ```

### Deduplication Not Happening

If jobs aren't sharing installation:

1. **Ensure identical `packages` values** across jobs
2. **Check job dependencies** don't prevent parallelization
3. **Verify no custom commands** that differ between jobs

### Cache Misses

If packages are reinstalling unnecessarily:

1. **Check lock files** haven't changed
2. **Verify version files** (.node-version, etc.) are consistent
3. **Review cache keys** with `--verbose` flag