---
title: Cache System
description: Intelligent caching with automatic cache key generation and built-in cache types
---

import {
  Code,
  Aside,
  Steps,
  CardGrid,
  Card,
} from '@astrojs/starlight/components';

Cigen can inject restore/save cache steps when a job declares `cache:`. Cache definitions are extensible via YAML; key calculation is simple by default and can be customized.

## Cache Key Structure

<Aside type="note">
  All cache keys follow a consistent structure for maximum cache hit rates and
  platform compatibility.
</Aside>

By default, injected keys include the cache name and the selected architecture, plus a checksum expression. You can override keys via `cache_definitions` if you need a specific pattern.

## Built-in Cache Types

Cigen ships default definitions for common technologies that you can extend or override. These drive detection and provide sensible paths; key templates can be provided if desired.

<CardGrid>
  <Card title="Ruby Gems" icon="seti:ruby">
    Detects Ruby & Bundler versions, uses Gemfile.lock for checksums
  </Card>
  <Card title="Node Modules" icon="seti:javascript">
    Supports npm, yarn, pnpm, and bun with appropriate lock files
  </Card>
  <Card title="Python Packages" icon="seti:python">
    Handles pip, pipenv, and poetry with virtual environment detection
  </Card>
  <Card title="Go Modules" icon="seti:go">
    Uses go.mod and go.sum for dependency tracking
  </Card>
</CardGrid>

### Ruby Gems

<Code
  code={`cache_definitions:
  gems:
    versions: [ruby, bundler]
    checksum_sources: [Gemfile, Gemfile.lock]
    paths: [vendor/bundle, .bundle]
`}
  lang="yaml"
  title="Ruby cache definition (paths and sources)"
/>

### Node.js Modules

<Code
  code={`cache_definitions:
  node_modules:
    versions: [node]
    checksum_sources:
      - package.json
      - detect: [package-lock.json, yarn.lock, bun.lockb, pnpm-lock.yaml]
    paths: [node_modules]
`}
  lang="yaml"
  title="Node.js cache definition"
/>

### Python Packages

<Code
  code={`cache_definitions:
  pip:
    versions: [python, pip]
    checksum_sources:
      - detect: [requirements.txt, Pipfile]
      - detect_optional: [requirements.lock, Pipfile.lock]
    paths:
      - detect: [.venv, venv]
      - ~/.cache/pip
`}
  lang="yaml"
  title="Python cache definition"
/>

## Using Caches in Jobs

### Cache Field vs Restore Cache

The `cache` and `restore_cache` fields serve different purposes:

- `cache`: restores before steps and saves after steps for the named caches
- `restore_cache`: restores only (read-only)

```yaml
# Read and write cache
jobs:
  build:
    cache: gems  # Restores before steps, saves after steps

# Read-only cache
jobs:
  test:
    restore_cache: gems  # Only restores, doesn't save
```

The `restore_cache` field is a shorthand for:

```yaml
cache:
  gems:
    restore: true # Always true by default anyway
    save: false # This is what restore_cache does
```

### Simple Cache Usage

<Code
  code={`jobs:
  test:
    image: cimg/ruby:3.3
    cache: gems  # Uses all defaults from gems cache definition
    steps:
      - run: bundle install
      - run: bundle exec rspec`}
  lang="yaml"
  title="Simple cache usage"
/>

This injects a `restore_cache` step before, and a `save_cache` step after, when the cache is declared on the job.

### Multiple Caches

<Code
  code={`jobs:
  full_stack_test:
    image: cimg/ruby:3.3
    cache: [gems, node_modules]  # Multiple cache types
    services: [postgres]
    steps:
      - run: bundle install
      - run: npm install
      - run: bundle exec rspec`}
  lang="yaml"
  title="Multiple caches"
/>

### Custom Cache Paths

<Code
  code={`jobs:
  test:
    image: cimg/ruby:3.3
    cache:
      gems:
        paths: [vendor/rubygems, .bundle]  # Override paths
        # versions and checksum_sources from definition
    steps:
      - run: bundle install --path vendor/rubygems`}
  lang="yaml"
  title="Customizing cache paths"
/>

## Advanced Cache Configuration

### Custom Cache Types

<Code code={`# In config.yml
cache_definitions:
  ml_models:
    versions: [python]
    checksum_sources:
      - requirements-ml.txt
      - models/config.json
    paths:
      - models/cache
      - ~/.cache/torch

webpack\*assets:
checksum_sources: # No versions - pure checksum cache - package.json - webpack.config.js - src/\*\*/\_.js
paths: - dist/assets - .webpack-cache`} lang="yaml" title="Custom cache definitions" />

### Cache Without Versions

For caches that don't depend on runtime versions:

<Code
  code={`cache_definitions:
  static_assets:
    checksum_sources: [assets/**/*.css, assets/**/*.js]
    paths: [public/compiled-assets]`}
  lang="yaml"
  title="Version-less cache"
/>

Example key: `linux-ubuntu22.04-amd64-static_assets-abc123def456`

### Path Detection

<Aside type="caution">
  Cigen validates cache paths exist before upload, preventing silent failures.
</Aside>

<Code
  code={`paths:
  - node_modules  # Required - job fails if missing
  - detect:       # At least one must exist
      - .venv
      - venv
      - virtualenv
  - detect_optional:  # All are optional
      - .cache/pre-commit
      - ~/.cache/myapp`}
  lang="yaml"
  title="Path detection strategies"
/>

## Manual Cache Steps

For fine-grained control, use manual cache steps:

<Code code={`steps:
  - restore_cache:
      name: Restore webpack cache
      key: webpack-{{ checksum "webpack.config.js" }}

- name: Build assets
  run: npm run build

- save_cache:
  name: Save webpack cache
  key: webpack-{{ checksum "webpack.config.js" }}
  paths: [.webpack-cache, dist/]`} lang="yaml" title="Manual cache steps" />

These steps:

- Use identical syntax across all CI providers
- Automatically use the configured cache backend
- Support template variables and functions

## Cache Backends

Configure different storage backends for various scenarios:

<Code code={`cache_backends:
  default: native  # Use CI provider's native cache

# Backend configurations

s3:
bucket: my-cache-bucket
region: us-east-1
prefix: cigen-cache/

redis:
url: redis://cache.example.com:6379
ttl: 604800 # 7 days

minio:
endpoint: minio.internal:9000
bucket: ci-cache
access_key: \${MINIO_ACCESS_KEY}
secret_key: \${MINIO_SECRET_KEY}

# Per-cache backend override

cache_definitions:
ml_models:
backend: s3 # Large models go to S3
paths: [models/]`} lang="yaml" title="Cache backend configuration" />

## Version Detection

### Detection Priority

Version sources are checked in order until one succeeds:

<Steps>

1. **Version files** - Read directly from committed files

   ```yaml
   - file: .ruby-version # Contains: 3.3.0
   ```

2. **Tool version files** - Extract using patterns

   ```yaml
   - file: .tool-versions
     pattern: 'ruby (.+)' # From: ruby 3.3.0
   ```

3. **Runtime commands** - Query installed versions

   ```yaml
   - command: 'ruby --version' # Auto-parses version numbers
   ```

4. **Raw commands** - Use output directly
   ```yaml
   - command: "grep -A1 'BUNDLED WITH' Gemfile.lock | tail -n1"
     parse_version: false # Use raw output
   ```

</Steps>

### Multi-Version Keys

When multiple versions are detected:

```
linux-ubuntu22.04-amd64-fullstack-ruby3.3.0-node20.11.0-abc123def
```

## Multi-Architecture Support

Cache keys automatically include architecture information:

<Code code={`jobs:
  build:
    architectures: [amd64, arm64]
    cache: gems

# Generates separate cache keys:

# linux-ubuntu22.04-amd64-gems-ruby3.3.0-abc123def

# linux-ubuntu22.04-arm64-gems-ruby3.3.0-abc123def`} lang="yaml" title="Architecture-specific caches" />

## Best Practices

<CardGrid>
  <Card title="Use Built-in Types" icon="approve-check">
    Leverage built-in cache definitions when possible - they handle edge cases
    and evolve with best practices
  </Card>
  <Card title="Include Lock Files" icon="document">
    Always include both manifest files (package.json) and lock files
    (package-lock.json) in checksum sources
  </Card>
  <Card title="Version Files in Git" icon="git-branch">
    Commit version files (.ruby-version, .node-version) to ensure consistent
    cache keys across environments
  </Card>
  <Card title="Descriptive Names" icon="pencil">
    Use clear, descriptive cache names (gems, node_modules) rather than generic
    names (cache1, deps)
  </Card>
</CardGrid>

## Troubleshooting

### Cache Misses

If caches aren't restoring when expected:

1. **Check version files exist** and are committed to git
2. **Verify checksum sources** haven't changed unexpectedly
3. **Use debug mode** to inspect generated cache keys:
   ```bash
   cigen generate --verbose
   ```

### Cache Conflicts

For jobs needing different cache strategies:

<Code code={`# Different cache strategies for same dependency type
cache_definitions:
  gems_production:
    type: gems  # Inherit from gems
    paths: [vendor/production-gems]

gems_development:
type: gems
paths: [vendor/development-gems, .bundle]`} lang="yaml" title="Resolving cache conflicts" />

## Implementation Details

### Cache Key Generation Process

<Steps>

1. **Detect platform** (OS, version, architecture)
2. **Resolve versions** from configured sources
3. **Calculate checksums** of dependency files
4. **Combine components** into final cache key
5. **Inject restore/save steps** at appropriate points

</Steps>

### Backend Selection

Cigen chooses cache backends based on:

- Global cache backend configuration
- Per-cache backend overrides
- Runner type (cloud vs self-hosted)
- Environment variables and context

The same cache configuration works across all backends - cigen handles the implementation details.
