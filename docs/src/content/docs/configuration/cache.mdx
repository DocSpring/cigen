---
title: Cache System
description: Intelligent caching with automatic cache key generation and built-in cache types
---

import { Code, Aside, Steps, CardGrid, Card } from '@astrojs/starlight/components';

Cigen provides an intelligent caching system that automatically generates optimal cache keys based on your project's runtime environments and dependencies.

## Cache Key Structure

<Aside type="note">
All cache keys follow a consistent structure for maximum cache hit rates and platform compatibility.
</Aside>

Cache keys use this pattern:
```
{{ os }}-{{ os_version }}-{{ arch }}-{{ cache_name }}-{{ versions }}-{{ checksum }}
```

Where:
- **Platform prefix** (`os`, `os_version`, `arch`) - Automatically included for all caches
- **cache_name** - The name you give to the cache (e.g., `gems`, `node_modules`)
- **versions** - Runtime versions detected from version files (e.g., `ruby3.3.0`)
- **checksum** - Combined hash of dependency files (e.g. package lock files)

Example cache key:
```
linux-ubuntu22.04-amd64-gems-ruby3.3.0-bundler2.5.6-abc123def456
```

## Built-in Cache Types

Cigen includes intelligent cache definitions for common technologies:

<CardGrid>
  <Card title="Ruby Gems" icon="seti:ruby">
    Detects Ruby & Bundler versions, uses Gemfile.lock for checksums
  </Card>
  <Card title="Node Modules" icon="seti:javascript">
    Supports npm, yarn, pnpm, and bun with appropriate lock files
  </Card>
  <Card title="Python Packages" icon="seti:python">
    Handles pip, pipenv, and poetry with virtual environment detection
  </Card>
  <Card title="Go Modules" icon="seti:go">
    Uses go.mod and go.sum for dependency tracking
  </Card>
</CardGrid>

### Ruby Gems

<Code code={`cache_definitions:
  gems:
    versions: [ruby, bundler]
    checksum_sources: [Gemfile, Gemfile.lock]
    paths: [vendor/bundle, .bundle]

version_sources:
  ruby:
    - file: .ruby-version
    - file: .tool-versions
      pattern: 'ruby (.+)'
    - command: 'ruby --version'
  bundler:
    - command: "grep -A1 'BUNDLED WITH' Gemfile.lock | tail -n1 | tr -d ' '"
      parse_version: false`} lang="yaml" title="Built-in Ruby cache definition" />

### Node.js Modules

<Code code={`cache_definitions:
  node_modules:
    versions: [node, detect: [npm, yarn, bun, pnpm]]
    checksum_sources:
      - package.json
      - detect: [package-lock.json, yarn.lock, bun.lockb, pnpm-lock.yaml]
    paths: [node_modules]

version_sources:
  node:
    - file: .node-version
    - file: .nvmrc
    - file: .tool-versions
      pattern: 'node (.+)'
    - command: 'node --version'`} lang="yaml" title="Built-in Node.js cache definition" />

### Python Packages

<Code code={`cache_definitions:
  pip:
    versions: [python, pip]
    checksum_sources:
      - detect: [requirements.txt, Pipfile]
      - detect_optional: [requirements.lock, Pipfile.lock]
    paths:
      - detect: [.venv, venv]
      - ~/.cache/pip

version_sources:
  python:
    - file: .python-version
    - file: .tool-versions
      pattern: 'python (.+)'
    - file: runtime.txt  # Heroku-style
    - command: 'python --version'`} lang="yaml" title="Built-in Python cache definition" />

## Using Caches in Jobs

### Simple Cache Usage

<Code code={`jobs:
  test:
    image: cimg/ruby:3.3
    cache: gems  # Uses all defaults from gems cache definition
    steps:
      - checkout
      - run: bundle install
      - run: bundle exec rspec`} lang="yaml" title="Simple cache usage" />

This automatically injects:
1. A `restore_cache` step before your steps
2. A `save_cache` step after your steps

### Multiple Caches

<Code code={`jobs:
  full_stack_test:
    image: cimg/ruby:3.3
    cache: [gems, node_modules]  # Multiple cache types
    services: [postgres]
    steps:
      - checkout
      - run: bundle install
      - run: npm install
      - run: bundle exec rspec`} lang="yaml" title="Multiple caches" />

### Custom Cache Paths

<Code code={`jobs:
  test:
    image: cimg/ruby:3.3
    cache:
      gems:
        paths: [vendor/rubygems, .bundle]  # Override paths
        # versions and checksum_sources from definition
    steps:
      - checkout
      - run: bundle install --path vendor/rubygems`} lang="yaml" title="Customizing cache paths" />

## Smart Cache Job Deduplication

<Aside type="tip">
**Intelligent Optimization**: When multiple jobs use the same cache, cigen automatically optimizes the workflow structure.
</Aside>

Cigen automatically detects cache usage patterns and optimizes accordingly:

### Single Job Usage (Inline)
```yaml
jobs:
  test:
    packages: node
    steps:
      - run: npm test
```
**Result**: Package installation is handled inline within the job.

### Multiple Job Usage (Dedicated Job)
```yaml
jobs:
  test:
    packages: node
    steps:
      - run: npm test

  lint:
    packages: node
    steps:
      - run: npm run lint

  build:
    packages: node
    steps:
      - run: npm run build
```

**Result**: Cigen automatically creates a dedicated `install_packages` job and adds it as a dependency:

```yaml
# Generated workflow structure:
jobs:
  install_packages:
    packages: node
    # Cache restore, npm install, cache save
  test:
    requires: [install_packages]
  lint:
    requires: [install_packages]
  build:
    requires: [install_packages]
```

This optimization:
- **Eliminates redundant installs** across multiple jobs
- **Runs installations once** in parallel with other setup
- **Reduces total CI time** through better parallelization
- **Maintains cache efficiency** with centralized dependency management

## Advanced Cache Configuration

### Custom Cache Types

<Code code={`# In cigen.yml
cache_definitions:
  ml_models:
    versions: [python]
    checksum_sources:
      - requirements-ml.txt
      - models/config.json
    paths:
      - models/cache
      - ~/.cache/torch

  webpack_assets:
    checksum_sources:  # No versions - pure checksum cache
      - package.json
      - webpack.config.js
      - src/**/*.js
    paths:
      - dist/assets
      - .webpack-cache`} lang="yaml" title="Custom cache definitions" />

### Cache Without Versions

For caches that don't depend on runtime versions:

<Code code={`cache_definitions:
  static_assets:
    checksum_sources: [assets/**/*.css, assets/**/*.js]
    paths: [public/compiled-assets]`} lang="yaml" title="Version-less cache" />

Example key: `linux-ubuntu22.04-amd64-static_assets-abc123def456`

### Path Detection

<Aside type="caution">
Cigen validates cache paths exist before upload, preventing silent failures.
</Aside>

<Code code={`paths:
  - node_modules  # Required - job fails if missing
  - detect:       # At least one must exist
      - .venv
      - venv
      - virtualenv
  - detect_optional:  # All are optional
      - .cache/pre-commit
      - ~/.cache/myapp`} lang="yaml" title="Path detection strategies" />

## Manual Cache Steps

For fine-grained control, use manual cache steps:

<Code code={`steps:
  - restore_cache:
      name: Restore webpack cache
      key: webpack-{{ checksum "webpack.config.js" }}

  - name: Build assets
    run: npm run build

  - save_cache:
      name: Save webpack cache
      key: webpack-{{ checksum "webpack.config.js" }}
      paths: [.webpack-cache, dist/]`} lang="yaml" title="Manual cache steps" />

These steps:
- Use identical syntax across all CI providers
- Automatically use the configured cache backend
- Support template variables and functions

## Cache Backends

Configure different storage backends for various scenarios:

<Code code={`cache_backends:
  default: native  # Use CI provider's native cache

  # Backend configurations
  s3:
    bucket: my-cache-bucket
    region: us-east-1
    prefix: cigen-cache/

  redis:
    url: redis://cache.example.com:6379
    ttl: 604800  # 7 days

  minio:
    endpoint: minio.internal:9000
    bucket: ci-cache
    access_key: \${MINIO_ACCESS_KEY}
    secret_key: \${MINIO_SECRET_KEY}

# Per-cache backend override
cache_definitions:
  ml_models:
    backend: s3  # Large models go to S3
    paths: [models/]`} lang="yaml" title="Cache backend configuration" />

## Version Detection

### Detection Priority

Version sources are checked in order until one succeeds:

<Steps>

1. **Version files** - Read directly from committed files
   ```yaml
   - file: .ruby-version  # Contains: 3.3.0
   ```

2. **Tool version files** - Extract using patterns
   ```yaml
   - file: .tool-versions
     pattern: 'ruby (.+)'  # From: ruby 3.3.0
   ```

3. **Runtime commands** - Query installed versions
   ```yaml
   - command: 'ruby --version'  # Auto-parses version numbers
   ```

4. **Raw commands** - Use output directly
   ```yaml
   - command: "grep -A1 'BUNDLED WITH' Gemfile.lock | tail -n1"
     parse_version: false  # Use raw output
   ```

</Steps>

### Multi-Version Keys

When multiple versions are detected:
```
linux-ubuntu22.04-amd64-fullstack-ruby3.3.0-node20.11.0-abc123def
```

## Multi-Architecture Support

Cache keys automatically include architecture information:

<Code code={`jobs:
  build:
    architectures: [amd64, arm64]
    cache: gems

# Generates separate cache keys:
# linux-ubuntu22.04-amd64-gems-ruby3.3.0-abc123def
# linux-ubuntu22.04-arm64-gems-ruby3.3.0-abc123def`} lang="yaml" title="Architecture-specific caches" />

## Best Practices

<CardGrid>
  <Card title="Use Built-in Types" icon="approve-check">
    Leverage built-in cache definitions when possible - they handle edge cases and evolve with best practices
  </Card>
  <Card title="Include Lock Files" icon="document">
    Always include both manifest files (package.json) and lock files (package-lock.json) in checksum sources
  </Card>
  <Card title="Version Files in Git" icon="git-branch">
    Commit version files (.ruby-version, .node-version) to ensure consistent cache keys across environments
  </Card>
  <Card title="Descriptive Names" icon="pencil">
    Use clear, descriptive cache names (gems, node_modules) rather than generic names (cache1, deps)
  </Card>
</CardGrid>

## Troubleshooting

### Cache Misses

If caches aren't restoring when expected:

1. **Check version files exist** and are committed to git
2. **Verify checksum sources** haven't changed unexpectedly
3. **Use debug mode** to inspect generated cache keys:
   ```bash
   cigen generate --verbose
   ```

### Cache Conflicts

For jobs needing different cache strategies:

<Code code={`# Different cache strategies for same dependency type
cache_definitions:
  gems_production:
    type: gems  # Inherit from gems
    paths: [vendor/production-gems]

  gems_development:
    type: gems
    paths: [vendor/development-gems, .bundle]`} lang="yaml" title="Resolving cache conflicts" />

## Implementation Details

### Cache Key Generation Process

<Steps>

1. **Detect platform** (OS, version, architecture)
2. **Resolve versions** from configured sources
3. **Calculate checksums** of dependency files
4. **Combine components** into final cache key
5. **Inject restore/save steps** at appropriate points

</Steps>

### Backend Selection

Cigen chooses cache backends based on:
- Global cache backend configuration
- Per-cache backend overrides
- Runner type (cloud vs self-hosted)
- Environment variables and context

The same cache configuration works across all backends - cigen handles the implementation details.