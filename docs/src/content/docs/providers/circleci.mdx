---
title: CircleCI Provider
description: CircleCI-specific features, workarounds, and configuration options
---

import {
  Code,
  Aside,
  Steps,
  CardGrid,
  Card,
} from '@astrojs/starlight/components';

The CircleCI provider generates native CircleCI configuration from cigen's universal format and validates step references against provider capabilities.

## Basic Configuration

<Code code={`provider: circleci
output_path: .circleci
output_filename: config.yml`} lang="yaml" title="Basic CircleCI configuration" />

## CircleCI Notes

- `setup: true` or `dynamic: true` in config enables CircleCI setup workflows.
- `docker_images` mapping can resolve architecture-specific image variants.

### Multi-Architecture Jobs

<Code code={`jobs:
  build_image:
    image: cimg/base:stable
    architectures: [amd64, arm64]  # Creates separate jobs
    steps:
      - run: docker build -t myapp:latest .

# Generated output:

jobs:
build_image_amd64:
docker: - image: cimg/base:stable
resource_class: medium

build_image_arm64:
docker: - image: cimg/base:stable
resource_class: arm.medium`} lang="yaml" title="Multi-architecture builds" />

Cigen automatically creates separate jobs per architecture and maintains dependencies.

### Approval Jobs

You can reference CircleCI approval jobs in your own config, and cigen will pass them through in generated YAML. API-based helpers are planned.

## Advanced Features

### OR Dependencies

CircleCI does not support OR dependencies. Cigen does not yet synthesize shims for this; it’s on the roadmap.

### Dynamic Configuration

<Code code={`setup: true  # or dynamic: true

parameters:
run_tests:
type: boolean
default: false
description: 'Whether to run test jobs'

deploy_environment:
type: enum
enum: [staging, production]
default: staging`} lang="yaml" title="Dynamic configuration" />

Enables CircleCI's dynamic configuration features:

- Conditional workflow execution
- Setup workflows that determine which jobs to run
- Parameter-driven job execution

### Context Support

<Code
  code={`jobs:
  deploy_production:
    image: cimg/base:stable
    context:
      - production-secrets
      - aws-credentials
    steps:
      - run: ./deploy.sh`}
  lang="yaml"
  title="CircleCI contexts"
/>

Maps directly to CircleCI contexts for environment-specific secrets and variables.

## Built-in Template Commands

Currently available:

- `continue_circleci_pipeline` — continue a setup workflow using the CircleCI continuation API

## Environment Variables

Common CircleCI variables like `CIRCLE_SHA1`, `CIRCLE_BUILD_URL`, etc. are available in jobs, as provided by CircleCI.

## Validation

The generator automatically validates configurations:

<Steps>
  1. **Schema validation** against CircleCI requirements 2. **CircleCI CLI
  validation** if `circleci` command is available: ```bash circleci config
  validate .circleci/config.yml ``` 3. **Dependency graph validation** for
  circular references 4. **Resource class compatibility** checking
</Steps>

## Limitations

- OR-dependencies: not supported
- Approval-status patching: not implemented
- Resource-class mapping between architectures: not implemented

## Best Practices

### Configuration Organization

<Code code={`# Use contexts for environment-specific secrets
jobs:
  deploy_staging:
    context: [staging-secrets]
  deploy_production:
    context: [production-secrets]

# Use setup/dynamic config when you need to compute a next-stage config

setup: true`} lang="yaml" title="CircleCI best practices" />

### Resource Class Mapping

Currently, resource classes are passed through as provided.

### Cache Configuration

<Code
  code={`# Leverage CircleCI's cache restoration patterns
cache:
  gems:
    # Automatic fallback keys for partial matches
    # Key: gems-ruby3.3.0-abc123
    # Fallback: gems-ruby3.3.0-
    # Fallback: gems-ruby3.3.0
    checksum_sources: [Gemfile.lock]
    paths: [vendor/bundle]`}
  lang="yaml"
  title="CircleCI cache patterns"
/>

## Migration from CircleCI YAML

When migrating existing CircleCI configurations:

<Steps>
  1. **Convert docker arrays** to separate `image` and `services` sections 2.
  **Optionally replace manual cache steps** with `cache: [type]` definitions 3. **Move
  commands** to separate files in `commands/` directory 4. **Convert approval
  jobs** to `type: approval` 5. **Add schema validation** with `$schema`
  property
</Steps>

## Example Migration

<Code code={`# Before (CircleCI YAML)
version: 2.1
jobs:
  test:
    docker:
      - image: cimg/ruby:3.3
      - image: postgres:15
        environment:
          POSTGRES_PASSWORD: test
    steps:
      - checkout
      - restore_cache:
          keys:
            - gems-{{ checksum "Gemfile.lock" }}
      - run: bundle install
      - save_cache:
          key: gems-{{ checksum "Gemfile.lock" }}
          paths: [vendor/bundle]

# After (Cigen format)

$schema: https://cigen.dev/schemas/v1/config-schema.json
provider: circleci

services:
postgres:
image: postgres:15
environment:
POSTGRES_PASSWORD: test

jobs:
test:
image: cimg/ruby:3.3
services: [postgres]
cache: gems
steps: - checkout - run: bundle install`} lang="yaml" title="CircleCI migration example" />

The cigen version is cleaner, more maintainable, and includes automatic optimizations like intelligent cache key generation and service container management.
