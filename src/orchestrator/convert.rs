use std::collections::HashMap;

use crate::plugin::protocol::{
    self, CacheDefinition, CigenSchema, JobDefinition, MatrixValue, ProjectConfig, RunStep,
    RunnerDefinition, SkipConfig, Step, UsesStep,
};
use crate::schema;

/// Convert schema::CigenConfig to protobuf CigenSchema
pub fn config_to_proto(config: &schema::CigenConfig) -> CigenSchema {
    CigenSchema {
        version: "1".to_string(),
        project: config.project.as_ref().map(project_to_proto),
        variables: HashMap::new(), // TODO: Add variable support
        jobs: config
            .jobs
            .iter()
            .map(|(id, job)| job_to_proto(id, job))
            .collect(),
        caches: config
            .caches
            .iter()
            .map(|(id, cache)| (id.clone(), cache_to_proto(cache)))
            .collect(),
        runners: config
            .runners
            .iter()
            .map(|(id, runner)| (id.clone(), runner_to_proto(runner)))
            .collect(),
        outputs: vec![], // Outputs are generated by plugins
    }
}

fn project_to_proto(project: &schema::ProjectConfig) -> ProjectConfig {
    ProjectConfig {
        name: project.name.clone(),
        default_runner: project.default_runner.clone().unwrap_or_default(),
    }
}

fn job_to_proto(id: &str, job: &schema::Job) -> JobDefinition {
    JobDefinition {
        id: id.to_string(),
        needs: job.needs.clone(),
        matrix: job
            .matrix
            .iter()
            .map(|(key, value)| (key.clone(), matrix_value_to_proto(value)))
            .collect(),
        packages: job.packages.clone(),
        steps: job.steps.iter().map(step_to_proto).collect(),
        skip_if: job.skip_if.as_ref().map(skip_config_to_proto),
        runner: job.runner.clone().unwrap_or_default(),
        env: job.env.clone(),
        image: job.image.clone(),
    }
}

fn matrix_value_to_proto(value: &schema::MatrixDimension) -> MatrixValue {
    match value {
        schema::MatrixDimension::List(values) => MatrixValue {
            values: values.clone(),
        },
    }
}

fn step_to_proto(step: &schema::Step) -> Step {
    match step {
        schema::Step::SimpleRun { run } => Step {
            step_type: Some(protocol::step::StepType::Run(RunStep {
                name: String::new(),
                command: run.clone(),
                env: HashMap::new(),
            })),
        },
        schema::Step::RunWithOptions { run } => Step {
            step_type: Some(protocol::step::StepType::Run(RunStep {
                name: run.name.clone().unwrap_or_default(),
                command: run.command.clone(),
                env: run.env.clone(),
            })),
        },
        schema::Step::Uses(uses) => Step {
            step_type: Some(protocol::step::StepType::Uses(UsesStep {
                name: String::new(),
                module: uses.uses.clone(),
                with: uses
                    .with
                    .iter()
                    .map(|(k, v)| (k.clone(), serde_yaml::to_string(v).unwrap_or_default()))
                    .collect(),
            })),
        },
    }
}

fn skip_config_to_proto(skip: &schema::SkipConditions) -> SkipConfig {
    SkipConfig {
        paths_unmodified: skip.paths_unmodified.clone(),
        env: skip.env.clone(),
        branch: skip.branch.clone(),
    }
}

fn cache_to_proto(cache: &schema::CacheDefinition) -> CacheDefinition {
    CacheDefinition {
        paths: cache.paths.clone(),
        key_parts: cache.key_parts.clone(),
        backend: format!("{:?}", cache.backend).to_lowercase(),
    }
}

fn runner_to_proto(runner: &schema::RunnerDefinition) -> RunnerDefinition {
    RunnerDefinition {
        provider_config: runner
            .provider_config
            .iter()
            .map(|(k, v)| (k.clone(), serde_yaml::to_string(v).unwrap_or_default()))
            .collect(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;

    fn create_simple_config() -> schema::CigenConfig {
        let mut jobs = HashMap::new();
        jobs.insert(
            "test".to_string(),
            schema::Job {
                needs: vec![],
                matrix: HashMap::new(),
                packages: vec!["ruby".to_string()],
                services: vec![],
                env: HashMap::new(),
                steps: vec![schema::Step::SimpleRun {
                    run: "bundle exec rspec".to_string(),
                }],
                skip_if: None,
                trigger: None,
                image: "ubuntu-latest".to_string(),
                runner: None,
                artifacts: vec![],
            },
        );

        schema::CigenConfig {
            project: None,
            providers: vec![],
            packages: vec![],
            jobs,
            caches: HashMap::new(),
            runners: HashMap::new(),
            provider_config: HashMap::new(),
        }
    }

    #[test]
    fn test_config_to_proto() {
        let config = create_simple_config();
        let proto = config_to_proto(&config);

        assert_eq!(proto.version, "1");
        assert_eq!(proto.jobs.len(), 1);
        assert_eq!(proto.jobs[0].id, "test");
        assert_eq!(proto.jobs[0].packages, vec!["ruby"]);
        assert_eq!(proto.jobs[0].steps.len(), 1);
    }

    #[test]
    fn test_step_conversion() {
        let simple_run = schema::Step::SimpleRun {
            run: "echo hello".to_string(),
        };

        let proto = step_to_proto(&simple_run);
        match proto.step_type {
            Some(protocol::step::StepType::Run(run)) => {
                assert_eq!(run.command, "echo hello");
            }
            _ => panic!("Expected Run step"),
        }
    }

    #[test]
    fn test_matrix_conversion() {
        let matrix = schema::MatrixDimension::List(vec!["3.2".to_string(), "3.3".to_string()]);

        let proto = matrix_value_to_proto(&matrix);
        assert_eq!(proto.values, vec!["3.2", "3.3"]);
    }
}
