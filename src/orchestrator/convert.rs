use std::collections::HashMap;

use crate::plugin::protocol::{
    self, CacheDefinition, CigenSchema, CommandDefinition as ProtoCommandDefinition,
    CommandParameter as ProtoCommandParameter, CustomStep, JobDefinition, MatrixValue,
    PackageSpec as ProtoPackageSpec, ProjectConfig, RestoreCacheStep, RunStep, RunnerDefinition,
    SaveCacheStep, SkipConfig, Step, StringList, UsesStep, WorkflowDefinition,
};
use crate::schema;
use serde_yaml::Value;

/// Convert schema::CigenConfig to protobuf CigenSchema
pub fn config_to_proto(config: &schema::CigenConfig) -> CigenSchema {
    CigenSchema {
        version: "1".to_string(),
        project: config.project.as_ref().map(project_to_proto),
        variables: HashMap::new(), // TODO: Add variable support
        jobs: config
            .jobs
            .iter()
            .map(|(id, job)| job_to_proto(id, job))
            .collect(),
        caches: config
            .caches
            .iter()
            .map(|(id, cache)| (id.clone(), cache_to_proto(cache)))
            .collect(),
        runners: config
            .runners
            .iter()
            .map(|(id, runner)| (id.clone(), runner_to_proto(runner)))
            .collect(),
        outputs: vec![], // Outputs are generated by plugins
        workflows: config
            .workflows
            .iter()
            .map(|(id, workflow)| workflow_to_proto(id, workflow))
            .collect(),
        source_file_groups: config
            .source_file_groups
            .iter()
            .map(|(id, values)| {
                (
                    id.clone(),
                    StringList {
                        values: values.clone(),
                    },
                )
            })
            .collect(),
        commands: config
            .commands
            .iter()
            .map(|(id, command)| (id.clone(), command_to_proto(command)))
            .collect(),
        provider_config: config
            .provider_config
            .iter()
            .map(|(id, value)| (id.clone(), serialize_value(value)))
            .collect(),
        raw_config_yaml: serialize_value(&Value::Mapping(config.raw.clone())),
    }
}

fn project_to_proto(project: &schema::ProjectConfig) -> ProjectConfig {
    ProjectConfig {
        name: project.name.clone(),
        default_runner: project.default_runner.clone().unwrap_or_default(),
    }
}

fn command_to_proto(command: &schema::CommandDefinition) -> ProtoCommandDefinition {
    ProtoCommandDefinition {
        description: command.description.clone().unwrap_or_default(),
        parameters: command
            .parameters
            .iter()
            .map(|(name, parameter)| (name.clone(), command_parameter_to_proto(parameter)))
            .collect(),
        steps: command.steps.iter().map(step_to_proto).collect(),
        extra: command
            .extra
            .iter()
            .map(|(k, v)| (k.clone(), serialize_value(v)))
            .collect(),
    }
}

fn command_parameter_to_proto(parameter: &schema::CommandParameter) -> ProtoCommandParameter {
    ProtoCommandParameter {
        r#type: parameter.parameter_type.clone().unwrap_or_default(),
        description: parameter.description.clone().unwrap_or_default(),
        default_yaml: parameter
            .default
            .as_ref()
            .map(serialize_value)
            .unwrap_or_default(),
        extra: mapping_to_string_map(&parameter.extra),
    }
}

fn job_to_proto(id: &str, job: &schema::Job) -> JobDefinition {
    JobDefinition {
        id: id.to_string(),
        needs: job.needs.clone(),
        matrix: job
            .matrix
            .iter()
            .map(|(key, value)| (key.clone(), matrix_value_to_proto(value)))
            .collect(),
        packages: job.packages.iter().map(|pkg| pkg.name.clone()).collect(),
        steps: job.steps.iter().map(step_to_proto).collect(),
        skip_if: job.skip_if.as_ref().map(skip_config_to_proto),
        runner: job.runner.clone().unwrap_or_default(),
        env: job.environment.clone(),
        image: job.image.clone(),
        workflow: job.workflow.clone().unwrap_or_else(|| "ci".to_string()),
        checkout: job
            .checkout
            .as_ref()
            .map(|options| {
                options
                    .iter()
                    .map(|(key, value)| (key.clone(), serialize_value(value)))
                    .collect()
            })
            .unwrap_or_default(),
        extra: job
            .extra
            .iter()
            .map(|(key, value)| (key.clone(), serialize_value(value)))
            .collect(),
        source_files: job.source_files.clone(),
        package_specs: job.packages.iter().map(package_to_proto).collect(),
        services: job.services.clone(),
    }
}

fn workflow_to_proto(id: &str, workflow: &schema::WorkflowConfig) -> WorkflowDefinition {
    WorkflowDefinition {
        id: id.to_string(),
        yaml: serialize_value(&workflow.raw),
        run_when: workflow
            .run_when
            .iter()
            .map(workflow_condition_to_proto)
            .collect(),
    }
}

fn workflow_condition_to_proto(
    condition: &schema::WorkflowCondition,
) -> protocol::WorkflowCondition {
    let kind = match condition
        .kind()
        .unwrap_or(schema::WorkflowConditionKind::Parameter)
    {
        schema::WorkflowConditionKind::Parameter => {
            protocol::WorkflowConditionKind::Parameter as i32
        }
        schema::WorkflowConditionKind::Variable => protocol::WorkflowConditionKind::Variable as i32,
        schema::WorkflowConditionKind::Env => protocol::WorkflowConditionKind::Env as i32,
        schema::WorkflowConditionKind::Expression => {
            protocol::WorkflowConditionKind::Expression as i32
        }
    };

    protocol::WorkflowCondition {
        kind,
        key: condition.key().unwrap_or_default().to_string(),
        equals_yaml: serialize_value(&condition.equals_value()),
        provider: condition.provider.clone().unwrap_or_default(),
        expression: condition.expression.clone().unwrap_or_default(),
    }
}

fn package_to_proto(package: &schema::PackageSpec) -> ProtoPackageSpec {
    ProtoPackageSpec {
        name: package.name.clone(),
        manager: package.manager.clone().unwrap_or_default(),
        path: package.path.clone().unwrap_or_default(),
        version: package.version.clone().unwrap_or_default(),
        extra: package
            .extra
            .iter()
            .map(|(k, v)| (k.clone(), serialize_value(v)))
            .collect(),
    }
}

fn matrix_value_to_proto(value: &schema::MatrixDimension) -> MatrixValue {
    match value {
        schema::MatrixDimension::List(values) => MatrixValue {
            values: values.clone(),
        },
    }
}

fn step_to_proto(step: &schema::Step) -> Step {
    match step {
        schema::Step::SimpleRun { run } => Step {
            step_type: Some(protocol::step::StepType::Run(RunStep {
                name: String::new(),
                command: run.clone(),
                env: HashMap::new(),
                r#if: String::new(),
            })),
        },
        schema::Step::RunWithOptions { run } => Step {
            step_type: Some(protocol::step::StepType::Run(RunStep {
                name: run.name.clone().unwrap_or_default(),
                command: run.command.clone(),
                env: run.env.clone(),
                r#if: run.condition.clone().unwrap_or_default(),
            })),
        },
        schema::Step::Uses(uses) => Step {
            step_type: Some(protocol::step::StepType::Uses(UsesStep {
                name: String::new(),
                module: uses.uses.clone(),
                with: uses
                    .with
                    .iter()
                    .map(|(k, v)| (k.clone(), serialize_value(v)))
                    .collect(),
                r#if: uses.condition.clone().unwrap_or_default(),
            })),
        },
        schema::Step::RestoreCache { restore_cache } => {
            let key = restore_cache
                .key
                .clone()
                .or_else(|| restore_cache.keys.first().cloned())
                .unwrap_or_default();
            Step {
                step_type: Some(protocol::step::StepType::RestoreCache(RestoreCacheStep {
                    name: restore_cache.name.clone().unwrap_or_default(),
                    key,
                    keys: restore_cache.keys.clone(),
                    restore_keys: restore_cache.restore_keys.clone(),
                    extra: restore_cache
                        .extra
                        .iter()
                        .map(|(k, v)| (k.clone(), serialize_value(v)))
                        .collect(),
                })),
            }
        }
        schema::Step::SaveCache { save_cache } => Step {
            step_type: Some(protocol::step::StepType::SaveCache(SaveCacheStep {
                name: save_cache.name.clone().unwrap_or_default(),
                key: save_cache.key.clone().unwrap_or_default(),
                paths: save_cache.paths.clone(),
                extra: save_cache
                    .extra
                    .iter()
                    .map(|(k, v)| (k.clone(), serialize_value(v)))
                    .collect(),
            })),
        },
        schema::Step::Custom(value) => {
            let kind = step_kind(value);
            Step {
                step_type: Some(protocol::step::StepType::Custom(CustomStep {
                    kind,
                    yaml: serialize_value(value),
                })),
            }
        }
    }
}

fn step_kind(value: &Value) -> String {
    match value {
        Value::Mapping(map) => map
            .keys()
            .next()
            .and_then(|k| k.as_str())
            .unwrap_or("custom")
            .to_string(),
        Value::String(s) => s.clone(),
        _ => "custom".to_string(),
    }
}

fn skip_config_to_proto(skip: &schema::SkipConditions) -> SkipConfig {
    SkipConfig {
        paths_unmodified: skip.paths_unmodified.clone(),
        env: skip.env.clone(),
        branch: skip.branch.clone(),
    }
}

fn cache_to_proto(cache: &schema::CacheDefinition) -> CacheDefinition {
    CacheDefinition {
        paths: cache.paths.clone(),
        key_parts: cache.key_parts.clone(),
        backend: format!("{:?}", cache.backend).to_lowercase(),
    }
}

fn runner_to_proto(runner: &schema::RunnerDefinition) -> RunnerDefinition {
    RunnerDefinition {
        provider_config: runner
            .provider_config
            .iter()
            .map(|(k, v)| (k.clone(), serialize_value(v)))
            .collect(),
    }
}

fn serialize_value(value: &Value) -> String {
    match serde_yaml::to_string(value) {
        Ok(mut s) => {
            if s.ends_with('\n') {
                s.pop();
                if s.ends_with('\r') {
                    s.pop();
                }
            }
            s
        }
        Err(_) => String::new(),
    }
}

fn mapping_to_string_map(mapping: &serde_yaml::Mapping) -> HashMap<String, String> {
    let mut result = HashMap::new();
    for (key, value) in mapping {
        if let Some(key_str) = key.as_str() {
            result.insert(key_str.to_string(), serialize_value(value));
        }
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;

    fn create_simple_config() -> schema::CigenConfig {
        let mut jobs = HashMap::new();
        jobs.insert(
            "test".to_string(),
            schema::Job {
                needs: vec![],
                matrix: HashMap::new(),
                packages: vec![schema::PackageSpec::from_name("ruby".to_string())],
                services: vec![],
                environment: HashMap::new(),
                checkout: None,
                steps: vec![schema::Step::SimpleRun {
                    run: "bundle exec rspec".to_string(),
                }],
                source_files: vec![],
                skip_if: None,
                trigger: None,
                image: "ubuntu-latest".to_string(),
                runner: None,
                artifacts: vec![],
                extra: HashMap::new(),
                workflow: None,
            },
        );

        schema::CigenConfig {
            project: None,
            providers: vec![],
            packages: vec![],
            source_file_groups: HashMap::new(),
            jobs,
            commands: HashMap::new(),
            caches: HashMap::new(),
            runners: HashMap::new(),
            provider_config: HashMap::new(),
            workflows: HashMap::new(),
            raw: Default::default(),
        }
    }

    #[test]
    fn test_config_to_proto() {
        let config = create_simple_config();
        let proto = config_to_proto(&config);

        assert_eq!(proto.version, "1");
        assert_eq!(proto.jobs.len(), 1);
        assert_eq!(proto.jobs[0].id, "test");
        assert_eq!(proto.jobs[0].packages, vec!["ruby"]);
        assert_eq!(proto.jobs[0].package_specs.len(), 1);
        assert_eq!(proto.jobs[0].steps.len(), 1);
    }

    #[test]
    fn test_step_conversion() {
        let simple_run = schema::Step::SimpleRun {
            run: "echo hello".to_string(),
        };

        let proto = step_to_proto(&simple_run);
        match proto.step_type {
            Some(protocol::step::StepType::Run(run)) => {
                assert_eq!(run.command, "echo hello");
            }
            _ => panic!("Expected Run step"),
        }
    }

    #[test]
    fn test_custom_step_conversion() {
        let value: Value = serde_yaml::from_str(
            r#"
store_artifacts:
  path: logs
"#,
        )
        .unwrap();
        let step = schema::Step::Custom(value);

        let proto = step_to_proto(&step);
        match proto.step_type {
            Some(protocol::step::StepType::Custom(custom)) => {
                assert_eq!(custom.kind, "store_artifacts");
            }
            other => panic!("Expected custom step, got {:?}", other),
        }
    }
}
