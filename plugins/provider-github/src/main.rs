/// GitHub Actions Provider Plugin for CIGen
///
/// This plugin wraps the existing GitHub Actions generator in the plugin protocol.
/// It serves as a "passthrough" plugin that validates the end-to-end plugin architecture.
use anyhow::Result;
use cigen::plugin::protocol::{plugin_server::Plugin, *};
use tonic::{Request, Response, Status};

/// Plugin version and metadata
const PLUGIN_NAME: &str = "provider/github";
const PLUGIN_VERSION: &str = "0.1.0";
const PROTOCOL_VERSION: u32 = 1;

/// GitHub Actions provider plugin
#[derive(Debug, Default)]
pub struct GitHubProvider {}

#[tonic::async_trait]
impl Plugin for GitHubProvider {
    async fn handshake(&self, request: Request<Hello>) -> Result<Response<PluginInfo>, Status> {
        let hello = request.into_inner();

        // Verify protocol compatibility
        if hello.core_protocol != PROTOCOL_VERSION {
            return Err(Status::failed_precondition(format!(
                "Protocol version mismatch: core={}, plugin={}",
                hello.core_protocol, PROTOCOL_VERSION
            )));
        }

        tracing::info!(
            "Handshake from core version {} (protocol {})",
            hello.core_version,
            hello.core_protocol
        );

        let info = PluginInfo {
            name: PLUGIN_NAME.to_string(),
            version: PLUGIN_VERSION.to_string(),
            protocol: PROTOCOL_VERSION,
            capabilities: vec![
                "provider:github".to_string(),
                "cache:native".to_string(),
                "matrix:build".to_string(),
            ],
            requires: vec![],
            conflicts_with: vec!["provider:*".to_string()],
            metadata: std::collections::HashMap::new(),
        };

        Ok(Response::new(info))
    }

    async fn detect(
        &self,
        request: Request<DetectRequest>,
    ) -> Result<Response<DetectResult>, Status> {
        let _req = request.into_inner();

        // For now, we don't auto-detect GitHub Actions
        // Later, we could check for .github/workflows/ directory
        let result = DetectResult {
            signals: vec![],
            facts: std::collections::HashMap::new(),
            confidence: 0.0,
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn plan(&self, request: Request<PlanRequest>) -> Result<Response<PlanResult>, Status> {
        let _req = request.into_inner();

        // TODO: Implement planning logic
        // For now, just return empty result
        let result = PlanResult {
            resources: vec![],
            deps: vec![],
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn generate(
        &self,
        request: Request<GenerateRequest>,
    ) -> Result<Response<GenerateResult>, Status> {
        let req = request.into_inner();

        tracing::info!(
            "Generating GitHub Actions config for target: {}",
            req.target
        );

        // TODO: Call the existing GitHub Actions generator
        // For now, return a simple test fragment
        let fragment = Fragment {
            path: ".github/workflows/ci.yml".to_string(),
            content: "# Generated by cigen-provider-github\nname: CI\n".to_string(),
            strategy: MergeStrategy::Replace as i32,
            order: 0,
            format: "yaml".to_string(),
        };

        let result = GenerateResult {
            fragments: vec![fragment],
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn validate(
        &self,
        request: Request<ValidateRequest>,
    ) -> Result<Response<ValidateResult>, Status> {
        let _req = request.into_inner();

        // TODO: Implement validation logic
        let result = ValidateResult {
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn preflight(
        &self,
        request: Request<PreflightRequest>,
    ) -> Result<Response<PreflightResult>, Status> {
        let _req = request.into_inner();

        // LIMITATION: Preflight logic is not yet implemented!
        // Currently ALL jobs will run (no cache/skip optimizations).
        // This means:
        // 1. Jobs will not skip based on unchanged file hashes
        // 2. Work signature caching is not active
        // 3. CI runs will be slower until this is implemented
        //
        // TODO: Implement work signature-based job skipping
        // - Compute hash of job inputs (files, env, package versions)
        // - Compare to cached signatures
        // - Set should_run=false if signatures match
        // - Populate new_signature with computed hash
        tracing::warn!(
            "Preflight check bypassed - job skipping not implemented, all jobs will run"
        );

        let result = PreflightResult {
            should_run: true, // Always run until preflight is implemented
            reason: "preflight_not_implemented".to_string(),
            new_signature: vec![],
        };

        Ok(Response::new(result))
    }
}

fn main() -> Result<()> {
    // Initialize logging to stderr (stdout is used for protobuf messages)
    // Note: Use underscores in environment variable (e.g., RUST_LOG=cigen_provider_github=debug)
    // even though the plugin name uses slashes (provider/github)
    tracing_subscriber::fmt()
        .with_writer(std::io::stderr)
        .with_env_filter(
            tracing_subscriber::EnvFilter::from_default_env()
                .add_directive("cigen_provider_github=info".parse()?),
        )
        .with_target(false)
        .without_time()
        .init();

    tracing::info!("Starting {} v{}", PLUGIN_NAME, PLUGIN_VERSION);

    // Use simple stdio communication with length-prefixed framing
    // Phase 1: Just handle handshake, exit after
    // Phase 2: Message loop for multiple requests

    use cigen::plugin::framing::{receive_message, send_message};
    use std::io::{stdin, stdout};

    // Read Hello message from stdin
    let hello: Hello = receive_message(&mut stdin().lock())?;

    tracing::info!(
        "Received handshake from core version {} (protocol {})",
        hello.core_version,
        hello.core_protocol
    );

    // Verify protocol compatibility
    if hello.core_protocol != PROTOCOL_VERSION {
        anyhow::bail!(
            "Protocol version mismatch: core={}, plugin={}",
            hello.core_protocol,
            PROTOCOL_VERSION
        );
    }

    // Send PluginInfo response
    let info = PluginInfo {
        name: PLUGIN_NAME.to_string(),
        version: PLUGIN_VERSION.to_string(),
        protocol: PROTOCOL_VERSION,
        capabilities: vec![
            "provider:github".to_string(),
            "cache:native".to_string(),
            "matrix:build".to_string(),
        ],
        requires: vec![],
        conflicts_with: vec!["provider:*".to_string()],
        metadata: std::collections::HashMap::new(),
    };

    send_message(&info, &mut stdout().lock())?;

    tracing::info!("Handshake successful, plugin info sent");

    // TODO: Implement message loop for hook invocations
    // For now, just exit after handshake
    tracing::info!("Shutting down (Phase 1: handshake-only mode)");

    Ok(())
}
