/// GitHub Actions Provider Plugin for CIGen
///
/// This plugin wraps the existing GitHub Actions generator in the plugin protocol.
/// It serves as a "passthrough" plugin that validates the end-to-end plugin architecture.
use anyhow::Result;
use cigen::plugin::protocol::{plugin_server::Plugin, *};
use tonic::{Request, Response, Status};

/// Plugin version and metadata
const PLUGIN_NAME: &str = "provider/github";
const PLUGIN_VERSION: &str = "0.1.0";
const PROTOCOL_VERSION: u32 = 1;

/// GitHub Actions provider plugin
#[derive(Debug, Default)]
pub struct GitHubProvider {}

#[tonic::async_trait]
impl Plugin for GitHubProvider {
    async fn handshake(&self, request: Request<Hello>) -> Result<Response<PluginInfo>, Status> {
        let hello = request.into_inner();

        // Verify protocol compatibility
        if hello.core_protocol != PROTOCOL_VERSION {
            return Err(Status::failed_precondition(format!(
                "Protocol version mismatch: core={}, plugin={}",
                hello.core_protocol, PROTOCOL_VERSION
            )));
        }

        tracing::info!(
            "Handshake from core version {} (protocol {})",
            hello.core_version,
            hello.core_protocol
        );

        let info = PluginInfo {
            name: PLUGIN_NAME.to_string(),
            version: PLUGIN_VERSION.to_string(),
            protocol: PROTOCOL_VERSION,
            capabilities: vec![
                "provider:github".to_string(),
                "cache:native".to_string(),
                "matrix:build".to_string(),
            ],
            requires: vec![],
            conflicts_with: vec!["provider:*".to_string()],
            metadata: std::collections::HashMap::new(),
        };

        Ok(Response::new(info))
    }

    async fn detect(
        &self,
        request: Request<DetectRequest>,
    ) -> Result<Response<DetectResult>, Status> {
        let _req = request.into_inner();

        // For now, we don't auto-detect GitHub Actions
        // Later, we could check for .github/workflows/ directory
        let result = DetectResult {
            signals: vec![],
            facts: std::collections::HashMap::new(),
            confidence: 0.0,
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn plan(&self, request: Request<PlanRequest>) -> Result<Response<PlanResult>, Status> {
        let _req = request.into_inner();

        // TODO: Implement planning logic
        // For now, just return empty result
        let result = PlanResult {
            resources: vec![],
            deps: vec![],
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn generate(
        &self,
        request: Request<GenerateRequest>,
    ) -> Result<Response<GenerateResult>, Status> {
        let req = request.into_inner();

        tracing::info!(
            "Generating GitHub Actions config for target: {}",
            req.target
        );

        // TODO: Call the existing GitHub Actions generator
        // For now, return a simple test fragment
        let fragment = Fragment {
            path: ".github/workflows/ci.yml".to_string(),
            content: "# Generated by cigen-provider-github\nname: CI\n".to_string(),
            strategy: MergeStrategy::Replace as i32,
            order: 0,
            format: "yaml".to_string(),
        };

        let result = GenerateResult {
            fragments: vec![fragment],
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn validate(
        &self,
        request: Request<ValidateRequest>,
    ) -> Result<Response<ValidateResult>, Status> {
        let _req = request.into_inner();

        // TODO: Implement validation logic
        let result = ValidateResult {
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn preflight(
        &self,
        request: Request<PreflightRequest>,
    ) -> Result<Response<PreflightResult>, Status> {
        let _req = request.into_inner();

        // LIMITATION: Preflight logic is not yet implemented!
        // Currently ALL jobs will run (no cache/skip optimizations).
        // This means:
        // 1. Jobs will not skip based on unchanged file hashes
        // 2. Work signature caching is not active
        // 3. CI runs will be slower until this is implemented
        //
        // TODO: Implement work signature-based job skipping
        // - Compute hash of job inputs (files, env, package versions)
        // - Compare to cached signatures
        // - Set should_run=false if signatures match
        // - Populate new_signature with computed hash
        tracing::warn!(
            "Preflight check bypassed - job skipping not implemented, all jobs will run"
        );

        let result = PreflightResult {
            should_run: true, // Always run until preflight is implemented
            reason: "preflight_not_implemented".to_string(),
            new_signature: vec![],
        };

        Ok(Response::new(result))
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    // Note: Use underscores in environment variable (e.g., RUST_LOG=cigen_provider_github=debug)
    // even though the plugin name uses slashes (provider/github)
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::from_default_env()
                .add_directive("cigen_provider_github=info".parse()?),
        )
        .with_target(false)
        .without_time()
        .init();

    tracing::info!("Starting {} v{}", PLUGIN_NAME, PLUGIN_VERSION);

    // Create the plugin service
    let _provider = GitHubProvider::default();

    // CRITICAL: gRPC server is NOT started!
    // The plugin cannot currently receive or respond to requests from the core.
    // This is a non-functional scaffold that demonstrates the plugin structure.
    //
    // TODO (HIGH PRIORITY): Wire up the plugin server
    // 1. Use src/plugin/stdio_transport.rs to create a StdioChannel
    // 2. Create a gRPC server with that transport
    // 3. Register the provider service (PluginServer::new(provider))
    // 4. Start the server to handle incoming requests
    //
    // Example pseudo-code:
    //   let channel = StdioChannel::new();
    //   let server = Server::builder()
    //       .add_service(PluginServer::new(provider))
    //       .serve_with_incoming(channel);
    //   server.await?;
    //
    // Without this, the plugin cannot be used for actual generation.
    // Integration tests cannot verify the plugin protocol.
    // The handshake and generate methods remain unexercised.
    tracing::warn!("Plugin server NOT started - this is a non-functional scaffold");
    tracing::info!("Next step: Implement stdio transport server in main()");

    // Keep running until killed (for manual testing/inspection only)
    tokio::signal::ctrl_c().await?;

    tracing::info!("Shutting down");

    Ok(())
}
