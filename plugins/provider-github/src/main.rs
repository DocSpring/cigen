/// GitHub Actions Provider Plugin for CIGen
///
/// This plugin wraps the existing GitHub Actions generator in the plugin protocol.
/// It serves as a "passthrough" plugin that validates the end-to-end plugin architecture.
use anyhow::Result;
use cigen::plugin::protocol::{plugin_server::Plugin, *};
use tonic::{Request, Response, Status};

/// Plugin version and metadata
const PLUGIN_NAME: &str = "provider/github";
const PLUGIN_VERSION: &str = "0.1.0";
const PROTOCOL_VERSION: u32 = 1;

/// GitHub Actions provider plugin
#[derive(Debug, Default)]
pub struct GitHubProvider {}

#[tonic::async_trait]
impl Plugin for GitHubProvider {
    async fn handshake(&self, request: Request<Hello>) -> Result<Response<PluginInfo>, Status> {
        let hello = request.into_inner();

        // Verify protocol compatibility
        if hello.core_protocol != PROTOCOL_VERSION {
            return Err(Status::failed_precondition(format!(
                "Protocol version mismatch: core={}, plugin={}",
                hello.core_protocol, PROTOCOL_VERSION
            )));
        }

        tracing::info!(
            "Handshake from core version {} (protocol {})",
            hello.core_version,
            hello.core_protocol
        );

        let info = PluginInfo {
            name: PLUGIN_NAME.to_string(),
            version: PLUGIN_VERSION.to_string(),
            protocol: PROTOCOL_VERSION,
            capabilities: vec![
                "provider:github".to_string(),
                "cache:native".to_string(),
                "matrix:build".to_string(),
            ],
            requires: vec![],
            conflicts_with: vec!["provider:*".to_string()],
            metadata: std::collections::HashMap::new(),
        };

        Ok(Response::new(info))
    }

    async fn detect(
        &self,
        request: Request<DetectRequest>,
    ) -> Result<Response<DetectResult>, Status> {
        let _req = request.into_inner();

        // For now, we don't auto-detect GitHub Actions
        // Later, we could check for .github/workflows/ directory
        let result = DetectResult {
            signals: vec![],
            facts: std::collections::HashMap::new(),
            confidence: 0.0,
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn plan(&self, request: Request<PlanRequest>) -> Result<Response<PlanResult>, Status> {
        let _req = request.into_inner();

        // TODO: Implement planning logic
        // For now, just return empty result
        let result = PlanResult {
            resources: vec![],
            deps: vec![],
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn generate(
        &self,
        request: Request<GenerateRequest>,
    ) -> Result<Response<GenerateResult>, Status> {
        let req = request.into_inner();

        tracing::info!(
            "Generating GitHub Actions config for target: {}",
            req.target
        );

        // TODO: Call the existing GitHub Actions generator
        // For now, return a simple test fragment
        let fragment = Fragment {
            path: ".github/workflows/ci.yml".to_string(),
            content: "# Generated by cigen-provider-github\nname: CI\n".to_string(),
            strategy: MergeStrategy::Replace as i32,
            order: 0,
            format: "yaml".to_string(),
        };

        let result = GenerateResult {
            fragments: vec![fragment],
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn validate(
        &self,
        request: Request<ValidateRequest>,
    ) -> Result<Response<ValidateResult>, Status> {
        let _req = request.into_inner();

        // TODO: Implement validation logic
        let result = ValidateResult {
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn preflight(
        &self,
        request: Request<PreflightRequest>,
    ) -> Result<Response<PreflightResult>, Status> {
        let _req = request.into_inner();

        // LIMITATION: Preflight logic is not yet implemented!
        // Currently ALL jobs will run (no cache/skip optimizations).
        // This means:
        // 1. Jobs will not skip based on unchanged file hashes
        // 2. Work signature caching is not active
        // 3. CI runs will be slower until this is implemented
        //
        // TODO: Implement work signature-based job skipping
        // - Compute hash of job inputs (files, env, package versions)
        // - Compare to cached signatures
        // - Set should_run=false if signatures match
        // - Populate new_signature with computed hash
        tracing::warn!(
            "Preflight check bypassed - job skipping not implemented, all jobs will run"
        );

        let result = PreflightResult {
            should_run: true, // Always run until preflight is implemented
            reason: "preflight_not_implemented".to_string(),
            new_signature: vec![],
        };

        Ok(Response::new(result))
    }
}

fn main() -> Result<()> {
    // Initialize logging to stderr (stdout is used for protobuf messages)
    // Note: Use underscores in environment variable (e.g., RUST_LOG=cigen_provider_github=debug)
    // even though the plugin name uses slashes (provider/github)
    tracing_subscriber::fmt()
        .with_writer(std::io::stderr)
        .with_env_filter(
            tracing_subscriber::EnvFilter::from_default_env()
                .add_directive("cigen_provider_github=info".parse()?),
        )
        .with_target(false)
        .without_time()
        .init();

    tracing::info!("Starting {} v{}", PLUGIN_NAME, PLUGIN_VERSION);

    // Use simple stdio communication with length-prefixed framing
    // Phase 1: Just handle handshake, exit after
    // Phase 2: Message loop for multiple requests

    use cigen::plugin::framing::{receive_message, send_message};
    use std::io::{stdin, stdout};

    // Read Hello message from stdin
    let hello: Hello = receive_message(&mut stdin().lock())?;

    tracing::info!(
        "Received handshake from core version {} (protocol {})",
        hello.core_version,
        hello.core_protocol
    );

    // Verify protocol compatibility
    if hello.core_protocol != PROTOCOL_VERSION {
        anyhow::bail!(
            "Protocol version mismatch: core={}, plugin={}",
            hello.core_protocol,
            PROTOCOL_VERSION
        );
    }

    // Send PluginInfo response
    let info = PluginInfo {
        name: PLUGIN_NAME.to_string(),
        version: PLUGIN_VERSION.to_string(),
        protocol: PROTOCOL_VERSION,
        capabilities: vec![
            "provider:github".to_string(),
            "cache:native".to_string(),
            "matrix:build".to_string(),
        ],
        requires: vec![],
        conflicts_with: vec!["provider:*".to_string()],
        metadata: std::collections::HashMap::new(),
    };

    send_message(&info, &mut stdout().lock())?;

    tracing::info!("Handshake successful, plugin info sent");

    // Message loop: handle Plan and Generate requests
    tracing::info!("Entering message loop...");

    let _provider = GitHubProvider::default();
    let mut stdin = stdin().lock();
    let mut stdout = stdout().lock();

    // Simple protocol: alternating Plan -> Generate
    // 1. Receive PlanRequest
    match receive_message::<PlanRequest, _>(&mut stdin) {
        Ok(_plan_req) => {
            tracing::info!("Received PlanRequest");

            let plan_result = PlanResult {
                resources: vec![],
                deps: vec![],
                diagnostics: vec![],
            };

            send_message(&plan_result, &mut stdout)?;
            tracing::info!("Sent PlanResult");
        }
        Err(e) => {
            tracing::warn!("Failed to receive PlanRequest (plugin may be shutting down): {e}");
            return Ok(());
        }
    }

    // 2. Receive GenerateRequest
    match receive_message::<GenerateRequest, _>(&mut stdin) {
        Ok(gen_req) => {
            tracing::info!("Received GenerateRequest for target: {}", gen_req.target);

            // Generate a simple workflow file
            let fragment = Fragment {
                path: ".github/workflows/ci.yml".to_string(),
                content: generate_workflow_yaml(&gen_req),
                strategy: MergeStrategy::Replace as i32,
                order: 0,
                format: "yaml".to_string(),
            };

            let gen_result = GenerateResult {
                fragments: vec![fragment],
                diagnostics: vec![],
            };

            send_message(&gen_result, &mut stdout)?;
            tracing::info!(
                "Sent GenerateResult with {} fragments",
                gen_result.fragments.len()
            );
        }
        Err(e) => {
            tracing::warn!("Failed to receive GenerateRequest: {e}");
            return Ok(());
        }
    }

    tracing::info!("Shutting down after completing workflow");
    Ok(())
}

/// Generate a basic GitHub Actions workflow YAML
fn generate_workflow_yaml(req: &GenerateRequest) -> String {
    let schema = req.schema.as_ref();

    let mut yaml = String::from("# Generated by cigen\n");
    yaml.push_str("name: CI\n\n");
    yaml.push_str("on:\n");
    yaml.push_str("  push:\n");
    yaml.push_str("    branches: [main]\n");
    yaml.push_str("  pull_request:\n\n");

    yaml.push_str("jobs:\n");

    if let Some(schema) = schema {
        for job in &schema.jobs {
            yaml.push_str(&format!("  {}:\n", job.id));
            yaml.push_str("    runs-on: ubuntu-latest\n");
            yaml.push_str("    steps:\n");
            yaml.push_str("      - uses: actions/checkout@v4\n");

            for step in &job.steps {
                if let Some(step_type) = &step.step_type {
                    match step_type {
                        cigen::plugin::protocol::step::StepType::Run(run) => {
                            if !run.name.is_empty() {
                                yaml.push_str(&format!("      - name: {}\n", run.name));
                            }
                            yaml.push_str(&format!("        run: {}\n", run.command));
                        }
                        cigen::plugin::protocol::step::StepType::Uses(uses) => {
                            yaml.push_str(&format!("      - uses: {}\n", uses.module));
                            if !uses.with.is_empty() {
                                yaml.push_str("        with:\n");
                                for (key, value) in &uses.with {
                                    yaml.push_str(&format!("          {}: {}\n", key, value));
                                }
                            }
                        }
                        _ => {}
                    }
                }
            }
        }
    }

    yaml
}
