/// GitHub Actions Provider Plugin for CIGen
use anyhow::Result;
use cigen::plugin::protocol::{plugin_server::Plugin, *};
use tonic::{Request, Response, Status};

/// Plugin version and metadata
const PLUGIN_NAME: &str = "provider/github";
const PLUGIN_VERSION: &str = "0.1.0";
const PROTOCOL_VERSION: u32 = 1;

/// GitHub Actions provider plugin
#[derive(Debug, Default)]
pub struct GitHubProvider {}

#[tonic::async_trait]
impl Plugin for GitHubProvider {
    async fn handshake(&self, request: Request<Hello>) -> Result<Response<PluginInfo>, Status> {
        let hello = request.into_inner();

        // Verify protocol compatibility
        if hello.core_protocol != PROTOCOL_VERSION {
            return Err(Status::failed_precondition(format!(
                "Protocol version mismatch: core={}, plugin={}",
                hello.core_protocol, PROTOCOL_VERSION
            )));
        }

        tracing::info!(
            "Handshake from core version {} (protocol {})",
            hello.core_version,
            hello.core_protocol
        );

        let info = PluginInfo {
            name: PLUGIN_NAME.to_string(),
            version: PLUGIN_VERSION.to_string(),
            protocol: PROTOCOL_VERSION,
            capabilities: vec![
                "provider:github".to_string(),
                "cache:native".to_string(),
                "matrix:build".to_string(),
            ],
            requires: vec![],
            conflicts_with: vec!["provider:*".to_string()],
            metadata: std::collections::HashMap::new(),
        };

        Ok(Response::new(info))
    }

    async fn detect(
        &self,
        request: Request<DetectRequest>,
    ) -> Result<Response<DetectResult>, Status> {
        let _req = request.into_inner();

        // For now, we don't auto-detect GitHub Actions
        // Later, we could check for .github/workflows/ directory
        let result = DetectResult {
            signals: vec![],
            facts: std::collections::HashMap::new(),
            confidence: 0.0,
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn plan(&self, request: Request<PlanRequest>) -> Result<Response<PlanResult>, Status> {
        let _req = request.into_inner();

        // TODO: Implement planning logic
        // For now, just return empty result
        let result = PlanResult {
            resources: vec![],
            deps: vec![],
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn generate(
        &self,
        request: Request<GenerateRequest>,
    ) -> Result<Response<GenerateResult>, Status> {
        let req = request.into_inner();

        tracing::info!(
            "Generating GitHub Actions config for target: {}",
            req.target
        );

        // TODO: Call the existing GitHub Actions generator
        // For now, return a simple test fragment
        let fragment = Fragment {
            path: ".github/workflows/ci.yml".to_string(),
            content: "# Generated by cigen-provider-github\nname: CI\n".to_string(),
            strategy: MergeStrategy::Replace as i32,
            order: 0,
            format: "yaml".to_string(),
        };

        let result = GenerateResult {
            fragments: vec![fragment],
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn validate(
        &self,
        request: Request<ValidateRequest>,
    ) -> Result<Response<ValidateResult>, Status> {
        let _req = request.into_inner();

        // TODO: Implement validation logic
        let result = ValidateResult {
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn preflight(
        &self,
        request: Request<PreflightRequest>,
    ) -> Result<Response<PreflightResult>, Status> {
        let _req = request.into_inner();

        // LIMITATION: Preflight logic is not yet implemented!
        // Currently ALL jobs will run (no cache/skip optimizations).
        // This means:
        // 1. Jobs will not skip based on unchanged file hashes
        // 2. Work signature caching is not active
        // 3. CI runs will be slower until this is implemented
        //
        // TODO: Implement work signature-based job skipping
        // - Compute hash of job inputs (files, env, package versions)
        // - Compare to cached signatures
        // - Set should_run=false if signatures match
        // - Populate new_signature with computed hash
        tracing::warn!(
            "Preflight check bypassed - job skipping not implemented, all jobs will run"
        );

        let result = PreflightResult {
            should_run: true, // Always run until preflight is implemented
            reason: "preflight_not_implemented".to_string(),
            new_signature: vec![],
        };

        Ok(Response::new(result))
    }
}

fn main() -> Result<()> {
    // Initialize logging to stderr (stdout is used for protobuf messages)
    // Note: Use underscores in environment variable (e.g., RUST_LOG=cigen_provider_github=debug)
    // even though the plugin name uses slashes (provider/github)
    tracing_subscriber::fmt()
        .with_writer(std::io::stderr)
        .with_env_filter(
            tracing_subscriber::EnvFilter::from_default_env()
                .add_directive("cigen_provider_github=info".parse()?),
        )
        .with_target(false)
        .without_time()
        .init();

    tracing::info!("Starting {} v{}", PLUGIN_NAME, PLUGIN_VERSION);

    // Use simple stdio communication with length-prefixed framing
    // Phase 1: Just handle handshake, exit after
    // Phase 2: Message loop for multiple requests

    use cigen::plugin::framing::{receive_message, send_message};
    use std::io::{stdin, stdout};

    // Read Hello message from stdin
    let hello: Hello = receive_message(&mut stdin().lock())?;

    tracing::info!(
        "Received handshake from core version {} (protocol {})",
        hello.core_version,
        hello.core_protocol
    );

    // Verify protocol compatibility
    if hello.core_protocol != PROTOCOL_VERSION {
        anyhow::bail!(
            "Protocol version mismatch: core={}, plugin={}",
            hello.core_protocol,
            PROTOCOL_VERSION
        );
    }

    // Send PluginInfo response
    let info = PluginInfo {
        name: PLUGIN_NAME.to_string(),
        version: PLUGIN_VERSION.to_string(),
        protocol: PROTOCOL_VERSION,
        capabilities: vec![
            "provider:github".to_string(),
            "cache:native".to_string(),
            "matrix:build".to_string(),
        ],
        requires: vec![],
        conflicts_with: vec!["provider:*".to_string()],
        metadata: std::collections::HashMap::new(),
    };

    send_message(&info, &mut stdout().lock())?;

    tracing::info!("Handshake successful, plugin info sent");

    // Message loop: handle Plan and Generate requests
    tracing::info!("Entering message loop...");

    let _provider = GitHubProvider::default();
    let mut stdin = stdin().lock();
    let mut stdout = stdout().lock();

    // Simple protocol: alternating Plan -> Generate
    // 1. Receive PlanRequest
    match receive_message::<PlanRequest, _>(&mut stdin) {
        Ok(_plan_req) => {
            tracing::info!("Received PlanRequest");

            let plan_result = PlanResult {
                resources: vec![],
                deps: vec![],
                diagnostics: vec![],
            };

            send_message(&plan_result, &mut stdout)?;
            tracing::info!("Sent PlanResult");
        }
        Err(e) => {
            tracing::warn!("Failed to receive PlanRequest (plugin may be shutting down): {e}");
            return Ok(());
        }
    }

    // 2. Receive GenerateRequest
    match receive_message::<GenerateRequest, _>(&mut stdin) {
        Ok(gen_req) => {
            tracing::info!("Received GenerateRequest for target: {}", gen_req.target);
            if let Some(schema) = &gen_req.schema {
                for job in &schema.jobs {
                    eprintln!("DEBUG: Job {} has image: '{}'", job.id, job.image);
                }
            }

            // Generate a simple workflow file
            let fragment = Fragment {
                path: ".github/workflows/ci.yml".to_string(),
                content: generate_workflow_yaml(&gen_req),
                strategy: MergeStrategy::Replace as i32,
                order: 0,
                format: "yaml".to_string(),
            };

            let gen_result = GenerateResult {
                fragments: vec![fragment],
                diagnostics: vec![],
            };

            send_message(&gen_result, &mut stdout)?;
            tracing::info!(
                "Sent GenerateResult with {} fragments",
                gen_result.fragments.len()
            );
        }
        Err(e) => {
            tracing::warn!("Failed to receive GenerateRequest: {e}");
            return Ok(());
        }
    }

    tracing::info!("Shutting down after completing workflow");
    Ok(())
}

/// Generate a GitHub Actions workflow YAML
fn generate_workflow_yaml(req: &GenerateRequest) -> String {
    use std::collections::HashMap;

    // Import GitHub Actions schema types from the plugin's own copy
    // These are copied from cigen's src/providers/github_actions/schema.rs
    #[derive(serde::Serialize)]
    #[allow(dead_code)]
    struct Workflow {
        name: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        on: Option<WorkflowTrigger>,
        jobs: HashMap<String, Job>,
    }

    #[derive(serde::Serialize)]
    #[serde(untagged)]
    #[allow(dead_code)]
    enum WorkflowTrigger {
        Detailed(HashMap<String, TriggerConfig>),
    }

    #[derive(serde::Serialize)]
    #[allow(dead_code)]
    struct TriggerConfig {
        #[serde(skip_serializing_if = "Option::is_none")]
        branches: Option<Vec<String>>,
    }

    #[derive(serde::Serialize)]
    #[allow(dead_code)]
    struct Job {
        #[serde(skip_serializing_if = "Option::is_none", rename = "runs-on")]
        runs_on: Option<RunsOn>,
        #[serde(skip_serializing_if = "Option::is_none")]
        needs: Option<Vec<String>>,
        #[serde(skip_serializing_if = "Option::is_none")]
        container: Option<Container>,
        #[serde(skip_serializing_if = "Option::is_none")]
        steps: Option<Vec<Step>>,
        #[serde(skip_serializing_if = "Option::is_none")]
        env: Option<HashMap<String, String>>,
    }

    #[derive(serde::Serialize)]
    #[serde(untagged)]
    #[allow(dead_code)]
    enum RunsOn {
        Single(String),
    }

    #[derive(serde::Serialize)]
    #[allow(dead_code)]
    struct Container {
        image: String,
    }

    #[derive(serde::Serialize)]
    #[allow(dead_code)]
    struct Step {
        #[serde(skip_serializing_if = "Option::is_none")]
        name: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        uses: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        run: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        with: Option<HashMap<String, serde_json::Value>>,
        #[serde(skip_serializing_if = "Option::is_none")]
        env: Option<HashMap<String, String>>,
    }

    let schema = match req.schema.as_ref() {
        Some(s) => s,
        None => return "# Error: No schema provided\n".to_string(),
    };

    // Build workflow structure
    let mut jobs = HashMap::new();

    for job_def in &schema.jobs {
        let mut steps = Vec::new();

        tracing::info!("Processing job {}: image = '{}'", job_def.id, job_def.image);

        // Determine if we need a container
        let (runs_on, container) =
            if job_def.image.starts_with("ubuntu") || job_def.image.starts_with("macos") {
                // Native runner - no container
                let runs_on = if job_def.image.starts_with("ubuntu") {
                    RunsOn::Single("ubuntu-latest".to_string())
                } else {
                    RunsOn::Single("macos-latest".to_string())
                };
                tracing::info!("Job {}: native runner, no container", job_def.id);
                (runs_on, None)
            } else {
                // Docker image - run in container
                tracing::info!(
                    "Job {}: using container image {}",
                    job_def.id,
                    job_def.image
                );
                let container = Container {
                    image: job_def.image.clone(),
                };
                (RunsOn::Single("ubuntu-latest".to_string()), Some(container))
            };

        // Add checkout step
        steps.push(Step {
            name: Some("Checkout code".to_string()),
            uses: Some("actions/checkout@v4".to_string()),
            run: None,
            with: None,
            env: None,
        });

        // Add user-defined steps
        for step in &job_def.steps {
            if let Some(step_type) = &step.step_type {
                match step_type {
                    cigen::plugin::protocol::step::StepType::RestoreCache(_) => {
                        // TODO: Implement cache restoration
                    }
                    cigen::plugin::protocol::step::StepType::SaveCache(_) => {
                        // TODO: Implement cache saving
                    }
                    cigen::plugin::protocol::step::StepType::Run(run) => {
                        steps.push(Step {
                            name: if run.name.is_empty() {
                                None
                            } else {
                                Some(run.name.clone())
                            },
                            uses: None,
                            run: Some(run.command.clone()),
                            with: None,
                            env: if run.env.is_empty() {
                                None
                            } else {
                                Some(run.env.clone())
                            },
                        });
                    }
                    cigen::plugin::protocol::step::StepType::Uses(uses) => {
                        // Convert with parameters (String values) to JSON values
                        let with_params = if uses.with.is_empty() {
                            None
                        } else {
                            Some(
                                uses.with
                                    .iter()
                                    .map(|(k, v)| (k.clone(), serde_json::Value::String(v.clone())))
                                    .collect(),
                            )
                        };

                        steps.push(Step {
                            name: if uses.name.is_empty() {
                                None
                            } else {
                                Some(uses.name.clone())
                            },
                            uses: Some(uses.module.clone()),
                            run: None,
                            with: with_params,
                            env: None,
                        });
                    }
                }
            }
        }

        let job = Job {
            runs_on: Some(runs_on),
            needs: if job_def.needs.is_empty() {
                None
            } else {
                Some(job_def.needs.clone())
            },
            container,
            steps: Some(steps),
            env: if job_def.env.is_empty() {
                None
            } else {
                Some(job_def.env.clone())
            },
        };

        jobs.insert(job_def.id.clone(), job);
    }

    // Build workflow triggers
    let mut triggers = HashMap::new();
    triggers.insert(
        "push".to_string(),
        TriggerConfig {
            branches: Some(vec!["main".to_string()]),
        },
    );
    triggers.insert("pull_request".to_string(), TriggerConfig { branches: None });

    let workflow = Workflow {
        name: "CI".to_string(),
        on: Some(WorkflowTrigger::Detailed(triggers)),
        jobs,
    };

    // Serialize to YAML
    let mut yaml = String::from("# DO NOT EDIT - This file is generated by cigen\n");
    yaml.push_str("# Source: .cigen/workflows/\n");
    yaml.push_str("# Regenerate with: cargo run -- --config .cigen generate\n");
    yaml.push_str("#\n");
    match serde_yaml::to_string(&workflow) {
        Ok(workflow_yaml) => {
            yaml.push_str(&workflow_yaml);
            yaml
        }
        Err(e) => {
            tracing::error!("Failed to serialize workflow: {}", e);
            format!("# Error: Failed to serialize workflow: {e}\n")
        }
    }
}
