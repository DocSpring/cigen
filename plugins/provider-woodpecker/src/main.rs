/// Woodpecker CI Provider Plugin for CIGen
use anyhow::{Context, Result};
use cigen::plugin::protocol::{diagnostic, plugin_server::Plugin, *};
use serde_yaml::{Mapping, Value};
use std::collections::{BTreeMap, HashMap};
use tonic::{Request, Response, Status};

/// Plugin version and metadata
const PLUGIN_NAME: &str = "provider/woodpecker";
const PLUGIN_VERSION: &str = "0.1.0";
const PROTOCOL_VERSION: u32 = 1;

/// Woodpecker CI provider plugin
#[derive(Debug, Default)]
pub struct WoodpeckerProvider {}

#[tonic::async_trait]
impl Plugin for WoodpeckerProvider {
    async fn handshake(&self, request: Request<Hello>) -> Result<Response<PluginInfo>, Status> {
        let hello = request.into_inner();

        if hello.core_protocol != PROTOCOL_VERSION {
            return Err(Status::failed_precondition(format!(
                "Protocol version mismatch: core={}, plugin={}",
                hello.core_protocol, PROTOCOL_VERSION
            )));
        }

        tracing::info!(
            "Handshake from core version {} (protocol {})",
            hello.core_version,
            hello.core_protocol
        );

        let info = PluginInfo {
            name: PLUGIN_NAME.to_string(),
            version: PLUGIN_VERSION.to_string(),
            protocol: PROTOCOL_VERSION,
            capabilities: vec![
                "provider:woodpecker".to_string(),
                "cache:native".to_string(),
            ],
            requires: vec![],
            conflicts_with: vec!["provider:*".to_string()],
            metadata: std::collections::HashMap::new(),
        };

        Ok(Response::new(info))
    }

    async fn detect(
        &self,
        request: Request<DetectRequest>,
    ) -> Result<Response<DetectResult>, Status> {
        let _req = request.into_inner();

        let result = DetectResult {
            signals: vec![],
            facts: std::collections::HashMap::new(),
            confidence: 0.0,
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn plan(&self, request: Request<PlanRequest>) -> Result<Response<PlanResult>, Status> {
        let _req = request.into_inner();

        let result = PlanResult {
            resources: vec![],
            deps: vec![],
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn generate(
        &self,
        request: Request<GenerateRequest>,
    ) -> Result<Response<GenerateResult>, Status> {
        let req = request.into_inner();

        tracing::info!("Generating Woodpecker CI config for target: {}", req.target);

        let fragment = Fragment {
            path: ".woodpecker.yaml".to_string(),
            content: "# Generated by cigen-provider-woodpecker\nsteps:\n  - name: hello\n    image: alpine\n    commands:\n      - echo 'Hello from Woodpecker'\n".to_string(),
            strategy: MergeStrategy::Replace as i32,
            order: 0,
            format: "yaml".to_string(),
        };

        let result = GenerateResult {
            fragments: vec![fragment],
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn validate(
        &self,
        request: Request<ValidateRequest>,
    ) -> Result<Response<ValidateResult>, Status> {
        let _req = request.into_inner();

        let result = ValidateResult {
            diagnostics: vec![],
        };

        Ok(Response::new(result))
    }

    async fn preflight(
        &self,
        request: Request<PreflightRequest>,
    ) -> Result<Response<PreflightResult>, Status> {
        let _req = request.into_inner();

        tracing::warn!(
            "Preflight check bypassed - job skipping not implemented, all jobs will run"
        );

        let result = PreflightResult {
            should_run: true,
            reason: "preflight_not_implemented".to_string(),
            new_signature: vec![],
        };

        Ok(Response::new(result))
    }
}

fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_writer(std::io::stderr)
        .with_env_filter(
            tracing_subscriber::EnvFilter::from_default_env()
                .add_directive("cigen_provider_woodpecker=info".parse()?),
        )
        .with_target(false)
        .without_time()
        .init();

    tracing::info!("Starting {} v{}", PLUGIN_NAME, PLUGIN_VERSION);

    use cigen::plugin::framing::{receive_message, send_message};
    use std::io::{stdin, stdout};

    // Read Hello message from stdin
    let hello: Hello = receive_message(&mut stdin().lock())?;

    tracing::info!(
        "Received handshake from core version {} (protocol {})",
        hello.core_version,
        hello.core_protocol
    );

    if hello.core_protocol != PROTOCOL_VERSION {
        anyhow::bail!(
            "Protocol version mismatch: core={}, plugin={}",
            hello.core_protocol,
            PROTOCOL_VERSION
        );
    }

    // Send PluginInfo response
    let info = PluginInfo {
        name: PLUGIN_NAME.to_string(),
        version: PLUGIN_VERSION.to_string(),
        protocol: PROTOCOL_VERSION,
        capabilities: vec![
            "provider:woodpecker".to_string(),
            "cache:native".to_string(),
        ],
        requires: vec![],
        conflicts_with: vec!["provider:*".to_string()],
        metadata: std::collections::HashMap::new(),
    };

    send_message(&info, &mut stdout().lock())?;

    tracing::info!("Handshake successful, plugin info sent");

    // Message loop
    tracing::info!("Entering message loop...");

    let mut stdin = stdin().lock();
    let mut stdout = stdout().lock();

    loop {
        match receive_message::<PlanRequest, _>(&mut stdin) {
            Ok(_plan_req) => {
                tracing::info!("Received PlanRequest");

                let plan_result = PlanResult {
                    resources: vec![],
                    deps: vec![],
                    diagnostics: vec![],
                };

                send_message(&plan_result, &mut stdout)?;
                tracing::info!("Sent PlanResult");
            }
            Err(e) => {
                tracing::warn!("Stopping plugin loop: {e}");
                break;
            }
        }

        match receive_message::<GenerateRequest, _>(&mut stdin) {
            Ok(gen_req) => {
                tracing::info!("Received GenerateRequest for target: {}", gen_req.target);

                let gen_result = build_generate_result(&gen_req);

                tracing::info!(
                    "Sending GenerateResult with {} fragment(s)",
                    gen_result.fragments.len()
                );
                send_message(&gen_result, &mut stdout)?;
            }
            Err(e) => {
                tracing::warn!("Failed to receive GenerateRequest: {e}");
                break;
            }
        }
    }

    tracing::info!("Plugin loop terminated");
    Ok(())
}

fn build_generate_result(req: &GenerateRequest) -> GenerateResult {
    let schema = match &req.schema {
        Some(schema) => schema,
        None => {
            return GenerateResult {
                fragments: vec![],
                diagnostics: vec![make_diagnostic(
                    "unknown",
                    anyhow::anyhow!("GenerateRequest missing schema"),
                )],
            };
        }
    };
    let (fragments, diagnostics) = build_workflow_fragments(schema);
    GenerateResult {
        fragments,
        diagnostics,
    }
}

fn build_workflow_fragments(schema: &CigenSchema) -> (Vec<Fragment>, Vec<Diagnostic>) {
    let mut diagnostics = Vec::new();

    // Group jobs by workflow
    let workflow_metadata = parse_workflow_metadata(schema, &mut diagnostics);
    let mut jobs_by_workflow: BTreeMap<String, Vec<JobDefinition>> = BTreeMap::new();
    for job in &schema.jobs {
        let workflow = if job.workflow.is_empty() {
            "ci"
        } else {
            &job.workflow
        };
        jobs_by_workflow
            .entry(workflow.to_string())
            .or_default()
            .push(job.clone());
    }

    let mut fragments = Vec::new();

    // Check workflow count before iterating (avoid borrow after move)
    let multiple_workflows = jobs_by_workflow.len() > 1;

    for (workflow_name, mut jobs) in jobs_by_workflow {
        jobs.sort_by(|a, b| a.id.cmp(&b.id));
        let metadata = workflow_metadata.get(&workflow_name);
        match render_workflow_file(&workflow_name, &jobs, metadata) {
            Ok(content) => {
                // Woodpecker uses .woodpecker/ directory for multiple workflows
                // or single .woodpecker.yaml for one workflow
                let path = if multiple_workflows {
                    format!(".woodpecker/{workflow_name}.yaml")
                } else {
                    ".woodpecker.yaml".to_string()
                };
                fragments.push(Fragment {
                    path,
                    content,
                    strategy: MergeStrategy::Replace as i32,
                    order: 0,
                    format: "yaml".to_string(),
                });
            }
            Err(error) => diagnostics.push(make_diagnostic(&workflow_name, error)),
        }
    }

    (fragments, diagnostics)
}

fn parse_workflow_metadata(
    schema: &CigenSchema,
    diagnostics: &mut Vec<Diagnostic>,
) -> HashMap<String, Mapping> {
    let mut result = HashMap::new();
    for workflow in &schema.workflows {
        match serde_yaml::from_str::<Value>(&workflow.yaml) {
            Ok(Value::Mapping(mapping)) => {
                result.insert(workflow.id.clone(), mapping);
            }
            Ok(other) => diagnostics.push(make_diagnostic(
                &workflow.id,
                anyhow::anyhow!(
                    "Expected mapping for workflow metadata but found {:?}",
                    other
                ),
            )),
            Err(err) => diagnostics.push(make_diagnostic(
                &workflow.id,
                anyhow::anyhow!("Failed to parse workflow metadata: {err}"),
            )),
        }
    }
    result
}

fn render_workflow_file(
    workflow_name: &str,
    jobs: &[JobDefinition],
    metadata: Option<&Mapping>,
) -> anyhow::Result<String> {
    let mut workflow_map = metadata.cloned().unwrap_or_else(Mapping::new);

    // Remove keys that we'll regenerate
    let steps_key = Value::String("steps".into());
    workflow_map.remove(&steps_key);

    // Woodpecker uses 'when' for triggers instead of 'on'
    let when_key = Value::String("when".into());
    if !workflow_map.contains_key(&when_key) {
        workflow_map.insert(when_key, default_when_value());
    }

    // Build steps from jobs - in Woodpecker, steps are equivalent to GitHub Actions jobs
    let steps = build_steps_sequence(workflow_name, jobs)?;
    workflow_map.insert(Value::String("steps".into()), Value::Sequence(steps));

    let mut yaml = String::from("# DO NOT EDIT - This file is generated by cigen\n");
    yaml.push_str("# Source: .cigen/workflows/\n");
    yaml.push_str("# Regenerate with: cargo run -- --config .cigen generate\n");
    yaml.push_str("#\n");

    let rendered = serde_yaml::to_string(&workflow_map)
        .with_context(|| format!("Failed to serialize workflow {workflow_name}"))?;
    yaml.push_str(&rendered);
    Ok(yaml)
}

fn default_when_value() -> Value {
    // Woodpecker trigger syntax
    let mut when_mapping = Mapping::new();
    when_mapping.insert(
        Value::String("event".into()),
        Value::Sequence(vec![
            Value::String("push".into()),
            Value::String("pull_request".into()),
        ]),
    );
    when_mapping.insert(Value::String("branch".into()), Value::String("main".into()));
    Value::Mapping(when_mapping)
}

fn build_steps_sequence(workflow_name: &str, jobs: &[JobDefinition]) -> anyhow::Result<Vec<Value>> {
    let mut steps: Vec<Value> = Vec::new();

    // Add checkout step first (Woodpecker has built-in clone, but we can customize)
    let mut clone_step = Mapping::new();
    clone_step.insert(Value::String("name".into()), Value::String("clone".into()));
    clone_step.insert(
        Value::String("image".into()),
        Value::String("woodpeckerci/plugin-git".into()),
    );
    steps.push(Value::Mapping(clone_step));

    // Convert each cigen job to Woodpecker steps
    for job in jobs {
        let job_steps = render_job_as_steps(job, workflow_name)?;
        steps.extend(job_steps);
    }

    Ok(steps)
}

fn render_job_as_steps(job: &JobDefinition, _workflow_name: &str) -> anyhow::Result<Vec<Value>> {
    let mut steps: Vec<Value> = Vec::new();

    // Get the base image for this job
    let image = if job.image.is_empty() {
        "alpine:latest".to_string()
    } else {
        job.image.clone()
    };

    // Add package cache steps (Woodpecker uses volume mounts or cache plugins)
    let cache_steps = build_package_cache_steps(job);
    steps.extend(cache_steps);

    // Convert job steps to Woodpecker steps
    for step in &job.steps {
        if let Some(step_type) = &step.step_type {
            match step_type {
                step::StepType::Run(run) => {
                    let mut step_map = Mapping::new();

                    // Step name
                    let name = if run.name.is_empty() {
                        format!("{}-run", job.id)
                    } else {
                        run.name.clone()
                    };
                    step_map.insert(Value::String("name".into()), Value::String(name));

                    // Image
                    step_map.insert(Value::String("image".into()), Value::String(image.clone()));

                    // Commands - Woodpecker uses 'commands' array
                    let commands: Vec<Value> = run
                        .command
                        .lines()
                        .filter(|line| !line.trim().is_empty())
                        .map(|line| Value::String(line.trim().to_string()))
                        .collect();
                    step_map.insert(Value::String("commands".into()), Value::Sequence(commands));

                    // Environment variables
                    if !run.env.is_empty() {
                        step_map.insert(
                            Value::String("environment".into()),
                            map_from_string_map(&run.env),
                        );
                    }

                    // Conditional execution - Woodpecker uses 'when' instead of 'if'
                    if !run.r#if.is_empty() {
                        let mut when_map = Mapping::new();
                        // Convert GitHub Actions expression to Woodpecker evaluate
                        when_map.insert(
                            Value::String("evaluate".into()),
                            Value::String(convert_condition(&run.r#if)),
                        );
                        step_map.insert(Value::String("when".into()), Value::Mapping(when_map));
                    }

                    // Add depends_on if job has dependencies
                    if !job.needs.is_empty() {
                        step_map.insert(
                            Value::String("depends_on".into()),
                            Value::Sequence(job.needs.iter().cloned().map(Value::String).collect()),
                        );
                    }

                    steps.push(Value::Mapping(step_map));
                }
                step::StepType::Uses(uses) => {
                    // Convert GitHub Actions 'uses' to Woodpecker plugin
                    let mut step_map = Mapping::new();

                    let name = if uses.name.is_empty() {
                        format!("{}-plugin", job.id)
                    } else {
                        uses.name.clone()
                    };
                    step_map.insert(Value::String("name".into()), Value::String(name));

                    // Convert action to Woodpecker plugin image
                    let plugin_image = convert_action_to_plugin(&uses.module);
                    step_map.insert(Value::String("image".into()), Value::String(plugin_image));

                    // 'with' becomes 'settings' in Woodpecker
                    if !uses.with.is_empty() {
                        let mut settings = Mapping::new();
                        for (key, value) in &uses.with {
                            settings.insert(Value::String(key.clone()), parse_yaml_value(value));
                        }
                        step_map.insert(Value::String("settings".into()), Value::Mapping(settings));
                    }

                    if !uses.r#if.is_empty() {
                        let mut when_map = Mapping::new();
                        when_map.insert(
                            Value::String("evaluate".into()),
                            Value::String(convert_condition(&uses.r#if)),
                        );
                        step_map.insert(Value::String("when".into()), Value::Mapping(when_map));
                    }

                    steps.push(Value::Mapping(step_map));
                }
                step::StepType::RestoreCache(_) | step::StepType::SaveCache(_) => {
                    // Woodpecker has different caching mechanisms
                    // Skip for now, can be implemented with volume mounts or plugins
                    continue;
                }
                step::StepType::Custom(_) => continue,
            }
        }
    }

    Ok(steps)
}

/// Build package cache steps for Woodpecker
/// Woodpecker handles caching differently - uses volume mounts or cache plugins
fn build_package_cache_steps(job: &JobDefinition) -> Vec<Value> {
    let mut steps = Vec::new();

    // Check for Rust/Cargo packages
    if job.packages.iter().any(|pkg| pkg == "rust") {
        let mut step = Mapping::new();
        step.insert(
            Value::String("name".into()),
            Value::String("Restore cargo cache".into()),
        );
        step.insert(
            Value::String("image".into()),
            Value::String("meltwater/drone-cache".into()),
        );

        let mut settings = Mapping::new();
        settings.insert(
            Value::String("backend".into()),
            Value::String("filesystem".into()),
        );
        settings.insert(Value::String("restore".into()), Value::Bool(true));
        settings.insert(
            Value::String("cache_key".into()),
            Value::String("{{ .Repo.Name }}-cargo-{{ checksum \"Cargo.lock\" }}".into()),
        );
        settings.insert(
            Value::String("mount".into()),
            Value::Sequence(vec![
                Value::String("~/.cargo/registry".into()),
                Value::String("~/.cargo/git".into()),
                Value::String("target".into()),
            ]),
        );
        step.insert(Value::String("settings".into()), Value::Mapping(settings));
        steps.push(Value::Mapping(step));
    }

    // Check for Node/pnpm packages
    if job.packages.iter().any(|pkg| pkg == "node") {
        let mut step = Mapping::new();
        step.insert(
            Value::String("name".into()),
            Value::String("Restore pnpm cache".into()),
        );
        step.insert(
            Value::String("image".into()),
            Value::String("meltwater/drone-cache".into()),
        );

        let mut settings = Mapping::new();
        settings.insert(
            Value::String("backend".into()),
            Value::String("filesystem".into()),
        );
        settings.insert(Value::String("restore".into()), Value::Bool(true));
        settings.insert(
            Value::String("cache_key".into()),
            Value::String("{{ .Repo.Name }}-pnpm-{{ checksum \"pnpm-lock.yaml\" }}".into()),
        );
        settings.insert(
            Value::String("mount".into()),
            Value::Sequence(vec![
                Value::String("~/.pnpm-store".into()),
                Value::String("node_modules".into()),
            ]),
        );
        step.insert(Value::String("settings".into()), Value::Mapping(settings));
        steps.push(Value::Mapping(step));
    }

    steps
}

/// Convert GitHub Actions 'uses' to equivalent Woodpecker plugin
fn convert_action_to_plugin(module: &str) -> String {
    // Map common GitHub Actions to Woodpecker plugins
    match module {
        s if s.starts_with("actions/checkout") => "woodpeckerci/plugin-git".to_string(),
        s if s.starts_with("actions/cache") => "meltwater/drone-cache".to_string(),
        s if s.starts_with("actions/upload-artifact") => {
            "plugins/s3".to_string() // Woodpecker uses S3 or other storage
        }
        s if s.starts_with("actions/download-artifact") => "plugins/s3".to_string(),
        s if s.starts_with("actions/setup-node") => "node:latest".to_string(),
        s if s.starts_with("docker/build-push-action") => "plugins/docker".to_string(),
        // For unknown actions, try to use as Docker image directly
        _ => {
            // Remove version tag for now
            let base = module.split('@').next().unwrap_or(module);
            // Convert GitHub action path to potential Docker image
            base.replace("actions/", "").replace('/', "-")
        }
    }
}

/// Convert GitHub Actions expression to Woodpecker evaluate expression
fn convert_condition(condition: &str) -> String {
    // Basic conversion - GitHub uses ${{ }} syntax, Woodpecker uses CI_ env vars
    condition
        .replace("${{ ", "")
        .replace(" }}", "")
        .replace("github.event_name", "CI_PIPELINE_EVENT")
        .replace("github.ref", "CI_COMMIT_REF")
        .replace("github.head_ref", "CI_COMMIT_SOURCE_BRANCH")
        .replace("github.base_ref", "CI_COMMIT_TARGET_BRANCH")
        .replace("github.repository", "CI_REPO")
        .replace("runner.os", "CI_SYSTEM_PLATFORM")
        .replace("success()", "CI_STEP_STATUS == \"success\"")
        .replace("failure()", "CI_STEP_STATUS == \"failure\"")
        .replace("always()", "true")
}

fn parse_yaml_value(input: &str) -> Value {
    serde_yaml::from_str(input).unwrap_or_else(|_| Value::String(input.to_string()))
}

fn map_from_string_map(map: &HashMap<String, String>) -> Value {
    let mut mapping = Mapping::new();
    for (key, value) in map {
        mapping.insert(Value::String(key.clone()), Value::String(value.clone()));
    }
    Value::Mapping(mapping)
}

fn make_diagnostic(workflow: &str, error: anyhow::Error) -> Diagnostic {
    Diagnostic {
        level: diagnostic::Level::Error as i32,
        code: "WOODPECKER_GENERATE_ERROR".to_string(),
        title: format!("Failed to generate workflow '{workflow}'"),
        message: error.to_string(),
        fix_hint: String::new(),
        loc: None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_action_to_plugin_conversion() {
        assert_eq!(
            convert_action_to_plugin("actions/checkout@v4"),
            "woodpeckerci/plugin-git"
        );
        assert_eq!(
            convert_action_to_plugin("actions/cache@v4"),
            "meltwater/drone-cache"
        );
        assert_eq!(
            convert_action_to_plugin("docker/build-push-action@v5"),
            "plugins/docker"
        );
    }

    #[test]
    fn test_condition_conversion() {
        assert_eq!(
            convert_condition("${{ github.event_name == 'push' }}"),
            "CI_PIPELINE_EVENT == 'push'"
        );
        assert_eq!(
            convert_condition("${{ github.ref == 'refs/heads/main' }}"),
            "CI_COMMIT_REF == 'refs/heads/main'"
        );
    }
}
